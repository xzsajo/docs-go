import{_ as s,c as a,a3 as l,o as t}from"./chunks/framework.CAwIQbWu.js";const o=JSON.parse('{"title":"作用域 VS 执行上下文","description":"","frontmatter":{},"headers":[],"relativePath":"JavaScript/作用域与执行上下文.md","filePath":"JavaScript/作用域与执行上下文.md","lastUpdated":1666854480000}'),n={name:"JavaScript/作用域与执行上下文.md"};function e(h,i,p,r,k,d){return t(),a("div",null,i[0]||(i[0]=[l(`<h1 id="作用域-vs-执行上下文" tabindex="-1">作用域 VS 执行上下文 <a class="header-anchor" href="#作用域-vs-执行上下文" aria-label="Permalink to &quot;作用域 VS 执行上下文&quot;">​</a></h1><p>笔者在前文 <a href="./作用域.html">作用域</a> 、<a href="./执行上下文与调用栈.html">执行上下文</a> 中介绍过作用域和执行上下文，它们是 JavaScript 中很重要的知识点，是基础中的重点，是重点中的基础。</p><p>我们讲过 JavaScript 中的作用域是词法作用域，与在哪里定义有关；而执行上下文则和调用有关，两者有关联但却是不同概念</p><h2 id="作用域" tabindex="-1">作用域 <a class="header-anchor" href="#作用域" aria-label="Permalink to &quot;作用域&quot;">​</a></h2><ul><li>作用域与哪里定义有关，在引擎编译时就知道它在哪里定义</li><li>其中函数作用域最为重要，因为作用域中的变量，作用域外不能访问，这起到了保护变量的作用</li><li>无生命周期</li><li>它可以理解为是“静态”的（词法作用域）</li><li>共全局作用域、函数作用域、块级作用域、eval 作用域</li></ul><h2 id="执行上下文" tabindex="-1">执行上下文 <a class="header-anchor" href="#执行上下文" aria-label="Permalink to &quot;执行上下文&quot;">​</a></h2><ul><li>而执行上下文与调用有关</li><li>它表示一段代码执行时所带的所有信息 <ul><li>包括 this、词法环境、变量环境（ES5标准）</li><li>结合之前 <a href="./this关键字.html">this</a> 所给的定义：<strong>谁调用它，this 就指向谁</strong> 就是和执行上下文相关。执行上下文也是如此，与调用者息息相关</li></ul></li><li>生命周期为两个阶段 <ul><li>创建阶段 <ul><li>确定 this 指，即我们熟知的 this 绑定</li><li>创建变量环境 <ul><li>环境记录器 <ul><li>登记 var、function 等声明的变量</li><li>此时会发生变量提升和函数提升</li></ul></li><li>对外部环境的引用（outer） <ul><li>指向父作用域（作用域在代码执行前就确定了）</li></ul></li></ul></li><li>创建词法环境 <ul><li>环境记录器 <ul><li>登记 let、const 等声明的变量</li><li>会发生变量提升（hoist），但是不会被初始化，所以提前使用会报 ReferenceError，如例1所示</li></ul></li><li>对外部环境的引用（outer） <ul><li>同样指向父作用域</li></ul></li></ul></li></ul></li><li>执行阶段 <ul><li>指向代码</li><li>确定作用域链</li></ul></li></ul></li><li>它则是“动态”的（与调用方相关）</li><li>共全局执行上下文、函数执行上下文、模块执行上下文、eval 执行上下文</li></ul><p>例子1：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// undefined</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">b </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ReferenceError</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">c </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ReferenceError</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">d </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// function d() {}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> c</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> d</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){}</span></span></code></pre></div><p>var 声明变量会被初始化为 undefined，一般函数（函数声明式写法）定义会被初始化为 <code>function xx(){}</code> ，let、const 则不会被初始化，所以 var 定义的变量可以提前使用但指为 undefined，一般函数定义可以正常提前使用，let、const 提前使用则会报错</p><blockquote><p>PS，如果使用函数表达式写法使用函数，则跟变量，如 var e = function(){} 或者 let f = () =&gt; {}</p></blockquote><p>以上就是作用域和指向上下文的各种区别</p>`,12)]))}const u=s(n,[["render",e]]);export{o as __pageData,u as default};
