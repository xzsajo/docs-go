import{_ as r,c as o,a3 as a,o as t}from"./chunks/framework.CAwIQbWu.js";const n=JSON.parse('{"title":"Web Worker 和 Web Socket","description":"","frontmatter":{},"headers":[],"relativePath":"Browser/webworker和websocket.md","filePath":"Browser/webworker和websocket.md","lastUpdated":1720434468000}'),k={name:"Browser/webworker和websocket.md"};function l(i,e,b,W,c,s){return t(),o("div",null,e[0]||(e[0]=[a('<h1 id="web-worker-和-web-socket" tabindex="-1">Web Worker 和 Web Socket <a class="header-anchor" href="#web-worker-和-web-socket" aria-label="Permalink to &quot;Web Worker 和 Web Socket&quot;">​</a></h1><p>HTML5 有两个新特性，Web Worker 和 Web Socket</p><h2 id="web-worker" tabindex="-1">Web Worker <a class="header-anchor" href="#web-worker" aria-label="Permalink to &quot;Web Worker&quot;">​</a></h2><p>Web Worker 允许 Web 应用程序创建后台线程来执行耗时的任务，而不会阻塞主线程的执行，它有以下特点：</p><ul><li>独立线程运行：浏览器提供一个子线程，可单独执行，不会阻塞主线程的执行</li><li>通信机制：Web Worker 与主线程之间通过消息传递的方式通信。主线程可以向 Worker 发送数据，Worker 也可以向主线程发送数据</li><li>数据隔离：Web Worker 运行在独立的线程，不能访问 DOM 等主线程专有的资源，可以避免 Worker 对主线程造成干扰</li><li>种类：HTML5 标准定义了两种 Web Worker，分别是 Dedicated Worker 和 Shared Worker。前者仅能被创建它的页面使用，后者可以被多个页面共享</li></ul><p>应用场景：</p><ul><li>图像处理和数据分析：耗时的计算任务放在 Worker 中执行，保持主线程的流畅</li><li>网路请求：使用 Worker 执行网络请求，避免阻塞主线程</li><li>离线缓存和数据存储：Worker 可以在后台执行数据的缓存和持久化操作</li></ul><h2 id="web-socket" tabindex="-1">Web Socket <a class="header-anchor" href="#web-socket" aria-label="Permalink to &quot;Web Socket&quot;">​</a></h2><p>Web Socket 是一种网络通信协议，它提供了浏览器与服务器之间的双向通讯通道，相比传统的 HTTP 协议，Web Socket 具有以下特点：</p><ul><li>持久连接</li><li>双向通信</li><li>实时性</li></ul><p>应用场景：实时聊天、实时推送、协同编辑、游戏和物联网</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>Web Worker 作用于浏览器，名为 Web 工人，它是为了让页面渲染更流畅而出的一个特性，把复杂的计算、耗时的网络请求放在 Worker 线程上，避免长时间的卡顿。当数据计算、请求有结果后给主线程，主线程拿到数据后直接渲染即可</p><p>Web Socket 作用于客户端（浏览器端）和服务器端，没 Socket 之前客户端只能请求服务端，服务端只能接受客户端的请求。有了 Socket 之后，服务端可以请求客户端，实现双向通讯</p>',14)]))}const w=r(k,[["render",l]]);export{n as __pageData,w as default};
