import{_ as a,c as r,a3 as t,o}from"./chunks/framework.CAwIQbWu.js";const h=JSON.parse('{"title":"React 性能优化","description":"","frontmatter":{},"headers":[],"relativePath":"React/性能优化.md","filePath":"React/性能优化.md","lastUpdated":1721698471000}'),i={name:"React/性能优化.md"};function l(n,e,p,c,m,s){return o(),r("div",null,e[0]||(e[0]=[t('<h1 id="react-性能优化" tabindex="-1">React 性能优化 <a class="header-anchor" href="#react-性能优化" aria-label="Permalink to &quot;React 性能优化&quot;">​</a></h1><blockquote><p>「性能优化」的核心应当是「不订阅视图无关的数据，以避免重复渲染」</p><p>而不是「订阅了视图无关的数据，用 useCallback/useMemo 来缓解性能问题」</p><p>——<a href="https://www.zhihu.com/question/390974405/answer/2001530387" target="_blank" rel="noreferrer">苏晗若</a></p></blockquote><p>说 React 性能优化，其实是想让页面更快加载出来，更流畅。他的本质是减少渲染真实 DOM 节点的频率，减少虚拟 DOM 对比的频率</p><p>在 <a href="./Fiber.html">Fiber</a> 一文中，我们讲过 React Fiber 的工作流，简单来说，它分为两个阶段：render 和 commit</p><p>Reconciler（协调器）工作的阶段被称为 render 阶段，Renderer（渲染器）工作的阶段被称为 commit 阶段</p><p>render 阶段会进行多次的调用（会被高优先级的任务打断，重新调用）</p><p>commit 阶段会执行一次调用（虚拟DOM 渲染到真实DOM上）</p><p>所以我们就要对着两个阶段进行优化， render 阶段的优化就是减少不变要的更新</p><blockquote><p>触发更新的方式有：forceUpdate、State更新、父组件 Render 触发子组件 Render</p></blockquote><p>commit 阶段是将虚拟DOM渲染到真实DOM上，所以我们需要在这阶段更新 state</p><p>简而言之，我们可以把优化方案分为三类</p><ol><li>render 阶段优化。即跳过不必要的组件的渲染更新</li><li>commit 阶段优化。即减少 commit 阶段耗时</li><li>非渲染方面的优化</li></ol><h2 id="render-阶段优化-即跳过不必要的组件更新" tabindex="-1">render 阶段优化，即跳过不必要的组件更新 <a class="header-anchor" href="#render-阶段优化-即跳过不必要的组件更新" aria-label="Permalink to &quot;render 阶段优化，即跳过不必要的组件更新&quot;">​</a></h2><h3 id="purecomponent、react-memo" tabindex="-1">PureComponent、React.memo <a class="header-anchor" href="#purecomponent、react-memo" aria-label="Permalink to &quot;PureComponent、React.memo&quot;">​</a></h3><p>如果只有父组件发生状态更新，即使父组件传给子组件的所有 Props 都没有修改，也会引起子组件的 Render 过程。PureComponent 和 React.memo 就是应对这种场景的</p><p>PureComponent 是对类组件的 Props 和 State 进行浅比较</p><p>React.memo 是对函数组件的 Props 进行浅比较</p><blockquote><p>浅比较：只会比较 props 对象的第一层属性,不会深入比较嵌套对象或数组的内部结构</p></blockquote><h3 id="usememo、usecallback-实现稳定的-props-值" tabindex="-1">useMemo、useCallback 实现稳定的 Props 值 <a class="header-anchor" href="#usememo、usecallback-实现稳定的-props-值" aria-label="Permalink to &quot;useMemo、useCallback 实现稳定的 Props 值&quot;">​</a></h3><p>如果传给子组件的派生状态或函数，每次都是新的引用，那么 PureComponent 和 React.memo 优化就会失效。所以需要使用 useMemo 和 useCallback 来生成稳定值，并结合 PureComponent 或 React.memo 避免子组件重新 Render</p><p>useMemo 缓存（复杂）值</p><p>useCallback 缓存函数</p><h3 id="列表项使用-key-属性" tabindex="-1">列表项使用 key 属性 <a class="header-anchor" href="#列表项使用-key-属性" aria-label="Permalink to &quot;列表项使用 key 属性&quot;">​</a></h3><p>为了 diff 算法能对比，需要给列表项中的每个值加上 key 属性</p><h3 id="shouldcomponentupdate" tabindex="-1">shouldComponentUpdate <a class="header-anchor" href="#shouldcomponentupdate" aria-label="Permalink to &quot;shouldComponentUpdate&quot;">​</a></h3><p>只适用于 class 组件，已经淘汰</p><h2 id="commit-阶段优化" tabindex="-1">commit 阶段优化 <a class="header-anchor" href="#commit-阶段优化" aria-label="Permalink to &quot;commit 阶段优化&quot;">​</a></h2><p>这类优化的目的是减少提交阶段耗时，该分类中仅有一条优化技巧</p><p><strong>避免在 didMount、didUpdate 中更新组件 State</strong></p><p>React 提交阶段的第二步是执行 commit 阶段钩子，它的执行会阻塞浏览器更新页面。如果在提交阶段钩子函数更新组件 State，会再次触发组件的更新流程，造成两倍耗时</p><h2 id="非渲染方面的优化" tabindex="-1">非渲染方面的优化 <a class="header-anchor" href="#非渲染方面的优化" aria-label="Permalink to &quot;非渲染方面的优化&quot;">​</a></h2><h3 id="组件按需挂载" tabindex="-1">组件按需挂载 <a class="header-anchor" href="#组件按需挂载" aria-label="Permalink to &quot;组件按需挂载&quot;">​</a></h3><p>可分为懒加载、懒渲染和虚拟列表三类</p><h4 id="懒加载" tabindex="-1">懒加载 <a class="header-anchor" href="#懒加载" aria-label="Permalink to &quot;懒加载&quot;">​</a></h4><p>懒加载的实现是通过 Webpack 的动态导入和 <code>React.lazy</code> 方法</p><h4 id="懒渲染" tabindex="-1">懒渲染 <a class="header-anchor" href="#懒渲染" aria-label="Permalink to &quot;懒渲染&quot;">​</a></h4><p>当组件进入或即将进入可视区域时才渲染组件。常见的组件 Modal/Drawer 等，当 visible 属性为 true 时才渲染组件内容，也可以认为是懒渲染的一种实现</p><h4 id="虚拟列表" tabindex="-1">虚拟列表 <a class="header-anchor" href="#虚拟列表" aria-label="Permalink to &quot;虚拟列表&quot;">​</a></h4><p>虚拟列表是懒渲染的一种特殊场景，不渲染所有的数据，只渲染可视区域中的数据。当用户滑动时，通过监听 scroll 来判断是上滑还是下拉，从而更新数据。同理 IntersectionObserver（交叉观察者） 和 getBoundingClientRect 都能实现</p><ul><li><p>IntersectionObserver：监听一个目标与它祖先元素或顶级文档视窗的交叉状态</p></li><li><p>getBoundingClientRect ：返回元素的大小及其相对视图的位置</p></li></ul><h2 id="参考资料" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料" aria-label="Permalink to &quot;参考资料&quot;">​</a></h2><ul><li><a href="https://juejin.cn/post/6935584878071119885" target="_blank" rel="noreferrer">React 性能优化 | 包括原理、技巧、Demo、工具使用</a></li><li><a href="https://zhuanlan.zhihu.com/p/74229420" target="_blank" rel="noreferrer">浅谈 React 性能优化的方向</a></li><li><a href="https://liyang0207.github.io/2018/10/11/%E3%80%8A%E8%AE%B0%E5%BF%86%E5%8C%96%E6%8A%80%E6%9C%AFmemoize-one%E3%80%8B/" target="_blank" rel="noreferrer">记忆化技术 memoize-one</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2NDAzMjE5NQ==&amp;mid=2247484658&amp;idx=1&amp;sn=8a71fd214af39a450a301c2338acad33&amp;chksm=ce6ec05ef91949488d55bf4eca89b30336027541d12042bd16fdc9e531814eca6f7a58085a45&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1568075495674&amp;sharer_shareid=778ad5bf3b27e0078eb105d7277263f6#rd" target="_blank" rel="noreferrer">「框架篇」React 中 的 9 种优化技术</a></li><li><a href="https://github.com/fi3ework/blog/issues/15" target="_blank" rel="noreferrer">React 高效渲染策略</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzkwODIwMDY2OQ==&amp;mid=2247488384&amp;idx=1&amp;sn=72499c2347a8b0bd43192942ab608d92&amp;source=41#wechat_redirect" target="_blank" rel="noreferrer">如何全方位优化你的超大型 React 应用 【原创精读】</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzkwODIwMDY2OQ==&amp;mid=2247488326&amp;idx=1&amp;sn=3c00c2ee434e95df1795e9bdebf2ede6&amp;source=41#wechat_redirect" target="_blank" rel="noreferrer">干货：深入了解 React 渲染原理及性能优化</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI1ODE4NzE1Nw==&amp;mid=2247487358&amp;idx=1&amp;sn=99298d0c25e9906c82fe01cc29f59950&amp;chksm=ea0d4584dd7acc92d2e26299feeb5b59b515bb0f866a415688b9d64fc566580a1b8f53be411b&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1582717186505&amp;sharer_shareid=778ad5bf3b27e0078eb105d7277263f6#rd" target="_blank" rel="noreferrer">可能你的 react 函数组件从来没有优化过</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzA4Nzg0MDM5Nw==&amp;mid=2247484801&amp;idx=1&amp;sn=093d31f10f791728272cfd50d96b3338&amp;chksm=90320663a7458f75961aef9dd819ed96e3d6a2fcb3e48bbce2b526990d55aeee2de8173fec4e&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1583667940585&amp;sharer_shareid=778ad5bf3b27e0078eb105d7277263f6#rd" target="_blank" rel="noreferrer">React 函数式组件性能优化指南</a></li><li><a href="https://mp.weixin.qq.com/s/8qfxKV9euWg9DcOoTbgleg" target="_blank" rel="noreferrer">打造高性能的 React 应用的几种方式总结</a></li><li><a href="https://mp.weixin.qq.com/s/x3Eqd4D8CDkm0ZTd7XCUwQ" target="_blank" rel="noreferrer">「react 进阶」react 开发者的不得不知道的八条优化建议</a></li><li><a href="https://jishuin.proginn.com/p/763bfbd5d4d0" target="_blank" rel="noreferrer">这可能是全网最全的 react 性能优化知识锦集</a></li><li><a href="https://cloud.tencent.com/developer/news/833663" target="_blank" rel="noreferrer">从源码中来，到业务中去，React 性能优化终极指南</a></li><li><a href="https://dev.to/harshdand/react-performance-optimization-tips-4238" target="_blank" rel="noreferrer">React Performance Optimization Tips</a></li><li><a href="https://www.zhihu.com/question/390974405/answer/2001530387" target="_blank" rel="noreferrer">新版 react 中，usecallback 和 usememo 是不是值得大量使用？</a></li><li><a href="https://juejin.cn/post/6935584878071119885" target="_blank" rel="noreferrer">React 性能优化 | 包括原理、技巧、Demo、工具使用</a></li></ul>',42)]))}const b=a(i,[["render",l]]);export{h as __pageData,b as default};
