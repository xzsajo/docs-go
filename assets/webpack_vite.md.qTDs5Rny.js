import{_ as a,c as t,a3 as r,o as i}from"./chunks/framework.CAwIQbWu.js";const h=JSON.parse('{"title":"Vite","description":"","frontmatter":{},"headers":[],"relativePath":"webpack/vite.md","filePath":"webpack/vite.md","lastUpdated":1723545460000}'),l={name:"webpack/vite.md"};function o(p,e,n,s,d,u){return i(),t("div",null,e[0]||(e[0]=[r('<h1 id="vite" tabindex="-1">Vite <a class="header-anchor" href="#vite" aria-label="Permalink to &quot;Vite&quot;">​</a></h1><p>为什么会有 vite？</p><p>如果应用比较复杂， webpack 的开发和打包速度就会很慢</p><ul><li>webpack dev server 冷启动时间比较长</li><li>webpack HMR 热更新的反应速度比较慢</li></ul><h3 id="回顾-webpack-初衷" tabindex="-1">回顾 webpack 初衷 <a class="header-anchor" href="#回顾-webpack-初衷" aria-label="Permalink to &quot;回顾 webpack 初衷&quot;">​</a></h3><p>之所以使用 webpack 打包，生成 bundle.js ，主要有两个原因</p><ul><li>浏览器环境并不很好</li><li>零散的模块会产生大量的 HTTP 请求</li></ul><h3 id="webpack-的解决方案" tabindex="-1">webpack 的解决方案 <a class="header-anchor" href="#webpack-的解决方案" aria-label="Permalink to &quot;webpack 的解决方案&quot;">​</a></h3><p>bundle 太大，就采用 Code Split 代码分割</p><ul><li>runtime</li><li>node modules -&gt; verdors</li><li>common</li><li>self</li></ul><p>加上 压缩代码，去除无用代码等手段</p><h2 id="新的解决思路" tabindex="-1">新的解决思路 <a class="header-anchor" href="#新的解决思路" aria-label="Permalink to &quot;新的解决思路&quot;">​</a></h2><h3 id="es-module" tabindex="-1">ES Module <a class="header-anchor" href="#es-module" aria-label="Permalink to &quot;ES Module&quot;">​</a></h3><p>随着浏览器对 ES 标准支持的逐渐完善，第一个问题就不存在了。现阶段绝大多数浏览器都是支持 ES Modules 的</p><p>其最大的特点是在浏览器端使用 export import 的方式导入和导出模块，在 script 标签里写 <code>type=&quot;module&quot;</code> ，然后使用 ES Module。</p><p><strong>Vite 的一个实现核心 - 拦截浏览器对模块的请求并返回处理后的结果</strong>我们来看下 Vite 是怎么处理的？</p><h3 id="大量请求的由http2解决" tabindex="-1">大量请求的由HTTP2解决 <a class="header-anchor" href="#大量请求的由http2解决" aria-label="Permalink to &quot;大量请求的由HTTP2解决&quot;">​</a></h3><p>HTTP 1.x 中，如果想并发多个请求，必须使用多个 TCP 链接，且浏览器为了控制资源，还会对单个域名有 6-8 个的 TCP 链接请求限制；HTTP 2 则可以使用<strong>多路复用</strong>，代替原来的序列和阻塞机制。所有请求都是通过一个 TCP 连接并发完成。</p><h2 id="vite-三大作用" tabindex="-1">Vite 三大作用 <a class="header-anchor" href="#vite-三大作用" aria-label="Permalink to &quot;Vite 三大作用&quot;">​</a></h2><p>即 Vite 的 3 大核心功能：Static Server + HMR + Compile</p><p><strong>3.1 快速的冷启动</strong></p><p><strong>因为 Webpack Dev Server 在启动时，需要先 build—遍，而 build 的过程是需要耗费很多时间的。</strong></p><p><strong>而 Vite 则完全不同，当我们执行 Vite serve 时（*<em>npm run dev*</em>），内部直接启动了 Web Server，并不会先编译所有的代码文件。</strong></p><p>关于支持 JSX， TSX，Typescript 编译到原生 JS —— Vite 引入了<strong>EsBuild</strong>，是使用 Go 写的，直接编译为 Native 代码，性能要比 TSC 好二三十倍</p><p><strong>3.3 真正的按需编译</strong></p><p>像 Webpack 这类工具的做法是将所有模块提前编译、打包进 bundle 里，换句话说，不管模块是否会被执行，都要被编译和打包到 bundle 里。随着项目越来越大打包后的 bundle 也越来越大，打包的速度自然也就越来越慢。</p><p>Vite 利用现代浏览器原生支持 ESM 特性，省略了对模块的打包。</p><p>对于需要编译的文件，Vite 采用的是另外一种模式：即时编译。也就是说，只有具体去请求某个文件时才会编译这个文件。所以，这种「即时编译」的好处主要体现在：按需编译。</p><h2 id="核心思路" tabindex="-1">核心思路 <a class="header-anchor" href="#核心思路" aria-label="Permalink to &quot;核心思路&quot;">​</a></h2><p><strong>初始启动静态服务</strong></p><p>初始执行命令 npm run dev --&gt; 实际就是启动了 /src/node/server/index.ts 如上文提到启动了一个 koa server, 该文件还使用了 chokidar 库创建一个 watcher，来监听文件变动：</p><p><strong>4.2 监听消息，拦截部分请求</strong></p><h3 id="_4-4-逻辑小结" tabindex="-1">4.4 逻辑小结 <a class="header-anchor" href="#_4-4-逻辑小结" aria-label="Permalink to &quot;4.4 逻辑小结&quot;">​</a></h3><ul><li>将当前项目目录作为静态文件服务器的根目录</li><li>拦截部分文件请求</li><li>处理代码中 import node_modules 中的模块 b</li><li>处理 Vue 单文件组件（SFC)的编译</li><li>通过 WebSocket 实现 HMR</li></ul><p>生产打包：Vite 用 rollup，打包体积更小（<strong>rollupInputOptions：定义 rollup 的插件功能</strong>）</p><h2 id="参考资料" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料" aria-label="Permalink to &quot;参考资料&quot;">​</a></h2><ul><li><a href="https://mp.weixin.qq.com/s/1LFnTt5Mbj3v_AU_DNMgtA" target="_blank" rel="noreferrer">速度与激情之 Vite 初体验</a></li></ul>',37)]))}const b=a(l,[["render",o]]);export{h as __pageData,b as default};
