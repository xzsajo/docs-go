import{_ as l,c as e,a3 as a,j as n,a as t,t as h,o as p}from"./chunks/framework.CAwIQbWu.js";const u=JSON.parse('{"title":"React Hooks 详解","description":"","frontmatter":{},"headers":[],"relativePath":"React/Hooks.md","filePath":"React/Hooks.md","lastUpdated":1722850347000}'),k={name:"React/Hooks.md"};function r(i,s,o,d,c,E){return p(),e("div",null,[s[2]||(s[2]=a(`<h1 id="react-hooks-详解" tabindex="-1">React Hooks 详解 <a class="header-anchor" href="#react-hooks-详解" aria-label="Permalink to &quot;React Hooks 详解&quot;">​</a></h1><blockquote><p>学习一项知识，必须问自己三个重要问题：1. 它的本质是什么。2. 它的第一原则是什么。3. 它的知识结构是怎样的</p></blockquote><h2 id="大纲" tabindex="-1">大纲 <a class="header-anchor" href="#大纲" aria-label="Permalink to &quot;大纲&quot;">​</a></h2><p>测试一下 Hook 的熟练程度</p><p>是什么</p><ul><li><p>为什么要有 Hook</p><ul><li>状态逻辑复用</li></ul></li><li><p>发展史</p><ul><li>Mixins</li><li>HOC</li></ul></li><li><p>Hook 的设计目标</p><ul><li>类组件的缺点</li><li>Hooks带来的好处</li></ul></li></ul><p>各个 Hooks</p><ul><li>useState（状态）</li><li>useEffect（副作用） <ul><li>与 useLayoutEffect 的区别</li></ul></li><li>useContext（上下文）</li><li>useReducer（Redux）</li><li><a href="./useCallback和useMemo.html">useMemo（记忆）以及useCallback（回调）</a></li><li><a href="./Ref以及useRef.html">Ref以及useRef</a></li><li><a href="./Hooks踩坑.html">Hooks 踩坑</a></li><li><a href="./Hooks实现原理.html">Hooks实现原理</a></li><li><a href="./手写自定义Hooks.html">手写自定义Hooks</a></li></ul><p>附录：使用规则</p><h2 id="测试一下-hooks-的熟练程度" tabindex="-1">测试一下 Hooks 的熟练程度 <a class="header-anchor" href="#测试一下-hooks-的熟练程度" aria-label="Permalink to &quot;测试一下 Hooks 的熟练程度&quot;">​</a></h2><p>为什么不能在 for 循环、if 语句里使用 Hook</p><p>React.memo、React.useCallback、React.usememo 的作用</p><p>useState 中的值是个对象，改变对象中的值，组件会渲染吗？如果用 React.memo() 包裹住呢</p><p>能否口喷 Hook 的原理是什么</p><p>Hooks 的本质是什么？为什么？</p><p>React Hook，它带来了哪些便利？</p><p>说下 React Hook 实现原理</p><p>React Hook 当中的 useEffect 是如何区分生命周期钩子的</p><p>useEffect(fn, []) 和 componentDidMount 有什么差异</p><hr><p>回答的如何？在了解一个概念前，疑惑越多，认识就越深</p><h2 id="是什么" tabindex="-1">是什么 <a class="header-anchor" href="#是什么" aria-label="Permalink to &quot;是什么&quot;">​</a></h2><p>React Hook 是 React 16.8 推出的新特性。它可以让你再不编写 class 的情况下使用 state 以及其他的 React 特性</p><h3 id="为什么要有-hook" tabindex="-1">为什么要有 Hook <a class="header-anchor" href="#为什么要有-hook" aria-label="Permalink to &quot;为什么要有 Hook&quot;">​</a></h3><p>我们一定要有个概念，即 React 的本质是什么？它的特征是 UI=f(data)、一切皆组件、声明式编程。那好，它既然是 UI=f(data)，data（数据）通过 function 来驱动 UI 视图变化，之前了解 <a href="./快问快答setState.html">setState</a> 时我们就说了，setState 是来管理状态的，因为在一个视图，你不能简单只展示，也要交互，交互就有状态的改变，React 是通过 setState 来改变状态。但 setState 是类组件中的 API，而每一个类组件写起来很麻烦，需要加各种生命周期，写一个组件为了是麻烦的，再加上各种优化会更麻烦。在函数式组件中，是没有状态的，一般当做渲染（无状态组件）</p><p><a href="https://zh-hans.reactjs.org/docs/hooks-intro.html#motivation" target="_blank" rel="noreferrer">官网</a>也曾经说过设计 Hooks 的动机有三：</p><blockquote><ol><li>在组件之间复用状态逻辑很难</li><li>复杂组件变得难以理解</li><li>难以理解的 class</li></ol></blockquote><p>我们先了解下状态逻辑复用的发展史</p><h3 id="发展史" tabindex="-1">发展史 <a class="header-anchor" href="#发展史" aria-label="Permalink to &quot;发展史&quot;">​</a></h3><h4 id="mixins-时代" tabindex="-1">Mixins 时代 <a class="header-anchor" href="#mixins-时代" aria-label="Permalink to &quot;Mixins 时代&quot;">​</a></h4><p>在我还没用 React 之前就有了，现在已经被淘汰。</p><blockquote><p>Mixins（混入）是一种通过扩展收集功能的方式，它本质上是将一个对象的属性拷贝到另一个对象上，不过你可以拷贝<code>任意多</code>个对象的<code>任意个</code>方法到一个新对象上去，这是<code>继承</code>所不能实现的。它的出现主要就是为了解决代码复用问题</p></blockquote><p>这里不对其做分析，React 官方文档在 <a href="https://zh-hans.reactjs.org/blog/2016/07/13/mixins-considered-harmful.html" target="_blank" rel="noreferrer">Mixins Considered Harmful</a> 一文中提到了 Mixins 带来的危害：</p><ul><li>Mixins 可能会相互依赖，相互耦合，不利于代码维护</li><li>不同的 Mixins 中的方法可能会相互冲突</li><li>Mixins 非常多时，组件时可以感知到的，甚至还要为其做相关处理，这样会给代码造成滚雪球的复杂性</li></ul><h4 id="hoc-高阶组件" tabindex="-1">HOC（高阶组件） <a class="header-anchor" href="#hoc-高阶组件" aria-label="Permalink to &quot;HOC（高阶组件）&quot;">​</a></h4><p>HOC 的原理其实很简单，它就是一个函数，且它接受一个组件作为参数，并返回一个新的组件，把复用的地方放在高阶组件中，你在使用的时候，只需要做不同用处</p><p>打个比方：就好像我给你一瓶水，你在渴的时候就会喝它；你在耍帅的时候拿它摆 POSE；你在别人需要的时候给他喝帮助人...</p><p>各位可以前往这里查看 <a href="https://codesandbox.io/s/hoc-demo-d9p9j?file=/src/App.js:0-629" target="_blank" rel="noreferrer">demo</a></p><p>HOC 的用处不单单是代码复用，还可以做权限控制、打印日志等。但它有也缺陷，例如 HOC 是在原组件上进行包裹或者嵌套，如果大量使用 HOC，将会产生非常多的嵌套，这会让调试变得非常困难；而且 HOC 可以劫持 props，在不遵守约定的情况下可能造成冲突</p><p>总结下 HOC：</p><ol><li>创建一个函数，该函数接收一个组件作为输入，除了组件还可以传递其他的参数</li><li>基于该组件返回一个不同的组件</li><li>它是将通用的逻辑进行处理，但会因为嵌套，使得调试难度变高</li></ol><h3 id="hook-的设计目标" tabindex="-1">Hook 的设计目标 <a class="header-anchor" href="#hook-的设计目标" aria-label="Permalink to &quot;Hook 的设计目标&quot;">​</a></h3><p>我们了解了 React 状态逻辑复用的发展史，结合类组件带来的不便。我们希望 React Hook 能这样的：</p><ol><li>无 Class 的复杂性</li><li>无生命周期的困扰</li><li>优雅地复用</li><li>对其 Class 组件已经具备的能力</li></ol><h4 id="类组件的缺点" tabindex="-1">类组件的缺点 <a class="header-anchor" href="#类组件的缺点" aria-label="Permalink to &quot;类组件的缺点&quot;">​</a></h4><ul><li><p>代码量多</p></li><li><p>this 指向：需要考虑 this 的指向问题</p></li><li><p>组件难以维护</p></li><li><p>状态逻辑难复用</p><ul><li>在组件之间复用状态逻辑很难，可能要用到 render props（渲染属性）或者 HOC（高阶组件），但无论时渲染属性还是高阶组件，都会在原先的组件外包裹一层父容器（一般都是 div 元素），导致层级冗余</li></ul></li></ul><h4 id="hooks-带来的好处" tabindex="-1">Hooks 带来的好处 <a class="header-anchor" href="#hooks-带来的好处" aria-label="Permalink to &quot;Hooks 带来的好处&quot;">​</a></h4><ul><li><p>逻辑复用</p></li><li><p>业务代码更聚合</p></li><li><p>写法简洁</p><ul><li>这个不用多说，写个 class 组件，需要写各种生命周期，如果优化，还需要在 shouldComponentUpdate 做渲染判断，但是函数式组件的 useMemo、memo 比 shouldComponentUpdate 不知道简洁到那里去</li></ul></li></ul><h2 id="各种-hooks" tabindex="-1">各种 Hooks <a class="header-anchor" href="#各种-hooks" aria-label="Permalink to &quot;各种 Hooks&quot;">​</a></h2><h3 id="usestate" tabindex="-1">useState <a class="header-anchor" href="#usestate" aria-label="Permalink to &quot;useState&quot;">​</a></h3><p>作用：让函数组件具有维持状态的能力</p><p>函数组件本身就是一个函数，不是类，因此没有构造函数 constructor(props)</p><p>任何你想定义的变量都可以单独拆分出去，独立定义，互不影响</p><p>在使用 useState 时，就会蹦出一个常见的面试题，<a href="./函数式组件与类组件有何不同.html">函数式组件与类组件有何不同</a> ，函数式组件能捕获渲染时的值</p><h3 id="注意事项" tabindex="-1">注意事项 <a class="header-anchor" href="#注意事项" aria-label="Permalink to &quot;注意事项&quot;">​</a></h3><p>1.不可局部更新</p><ul><li>如果 state 是一个对象，能否部分更新，不能</li><li>setState 不会帮我们合并属性，可使用 展开运算符（...）来解决</li><li>useReducer 也不会合并属性</li></ul><p>2.地址要变</p><ul><li>setState(obj) 如果 obj 地址不变，那么 React 就认为数据没有变化</li></ul><p>3.useState 和 setState 都接受函数</p><ul><li>setState(i =&gt; i + 1)</li></ul><h3 id="useeffect" tabindex="-1">useEffect <a class="header-anchor" href="#useeffect" aria-label="Permalink to &quot;useEffect&quot;">​</a></h3><p>作用：执行副作用</p><blockquote><p>PS：什么是副作用？对环境的改变就是副作用</p></blockquote><p>每一次渲染都有它自己的 props 和 state</p><p>用途：</p><ul><li>作为 componentDidMount 使用，[] 作为第二个参数</li><li>作为 componentDidUpdate 使用，可指定依赖</li><li>作为 componentWillUnmount 使用，通过 return</li></ul><p>如果同时存在多个 useEffect，会按照出现次序执行</p><p>在我们讨论 effects 之前，我们需要先讨论一下渲染（rendering）</p><p>我们来看一个计数器组件 Counter</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Counter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">count</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setCount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;You clicked {count} times&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> onClick</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setCount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)}&gt;Click me&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>我们的组件第一次渲染的时候，从<code>useState()</code>拿到<code>count</code>的初始值<code>0</code>。当我们调用<code>setCount(1)</code>，React 会再次渲染组件，这一次<code>count</code>是<code>1</code>。如此等等：</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// During first render</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Counter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Returned by useState()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;You clicked {count} times&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// After a click, our function is called again</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Counter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Returned by useState()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;You clicked {count} times&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// After another click, our function is called again</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Counter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Returned by useState()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;You clicked {count} times&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>当我们更新状态的时候，React 会重新渲染组件。每一次渲染都能拿到独立的 count 状态，这个状态值是函数中的一个常量</p><h4 id="每一次渲染都有它自己的事件处理函数" tabindex="-1">每一次渲染都有它自己的事件处理函数 <a class="header-anchor" href="#每一次渲染都有它自己的事件处理函数" aria-label="Permalink to &quot;每一次渲染都有它自己的事件处理函数&quot;">​</a></h4><p>到目前为止一切都还好。那么事件处理函数呢？</p><p>看下面的这个例子。它在三秒后会 alert 点击次数<code>count</code>：</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Counter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">count</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setCount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> handleAlertClick</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            alert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;You clicked on: &#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> count);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;You clicked {count} times&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> onClick</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setCount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)}&gt;Click me&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> onClick</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{handleAlertClick}&gt;Show alert&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>如果我按照下面的步骤去操作：</p><ul><li>点击增加 counter 到 3</li><li>点击一下“Show alert”</li><li>点击增加 counter 到 5 并且在定时器回调触发前完成</li></ul><p>渲染的是 3，捕获当前的值</p><p>它究竟是如何工作的呢？</p><p>我们发现 count 在每一次函数调用中都是一个常量值。值得强调的是——我们的组件函数每次渲染都会被调用，但是每一次调用中 count 值都是常量，并且它被赋予了当前渲染中的状态值</p><p>这就解释了我们的事件处理函数如何捕获点击时候的 count 值。如果我们应用相同的替换原理，每一次渲染“看到”的是它自己的 count</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// During first render</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Counter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Returned by useState()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> handleAlertClick</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            alert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;You clicked on: &#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> count);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// After a click, our function is called again</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Counter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Returned by useState()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> handleAlertClick</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            alert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;You clicked on: &#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> count);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// After another click, our function is called again</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Counter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Returned by useState()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> handleAlertClick</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            alert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;You clicked on: &#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> count);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>所以实际上，每次渲染都有一个“新版本”的 handleAlertClick。每一个版本的 handleAlertClick “记住”了它自己的 count</p><h3 id="uselayouteffect" tabindex="-1">useLayoutEffect <a class="header-anchor" href="#uselayouteffect" aria-label="Permalink to &quot;useLayoutEffect&quot;">​</a></h3><p>名曰：布局副作用</p><p>它与 useEffect 常做对比，两者执行时机不同、性能影响不同、使用场景也不同</p><ul><li>useEffect 会异步执行 <ul><li>在 commit 阶段的 before mutation 阶段调用，但是会在 layout 阶段完成后才异步执行</li><li>所以它不会阻塞浏览器的绘制</li><li><strong>在浏览器渲染完成后执行</strong></li></ul></li><li>useLayoutEffect 是同步执行 <ul><li>在 commit 阶段的 layout 阶段同步执行</li><li>等价于类组件中的 componentDidMount</li><li>可以读取并同步修改 DOM，确保 DOM 的变化在用户看到之前完成</li><li>所以它会阻塞浏览器的绘制</li><li><strong>在浏览器渲染前执行</strong></li></ul></li></ul><h4 id="示意图" tabindex="-1">示意图 <a class="header-anchor" href="#示意图" aria-label="Permalink to &quot;示意图&quot;">​</a></h4><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">APP</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> React.element </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> VDOM</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> --&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> DOM</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> --&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 修改视图</span></span></code></pre></div><p><code>useLayoutEffect</code> 发生在 DOM 和 修改视图 阶段之间</p><p><code>useEffect</code> 发生在修改 DOM 之后</p><h4 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h4><p>简单来说，useLayoutEffect 总是比 useEffect 先执行</p><p>为了用户体验，优先使用useEffect（优先渲染）</p><h3 id="usereducer" tabindex="-1">useReducer <a class="header-anchor" href="#usereducer" aria-label="Permalink to &quot;useReducer&quot;">​</a></h3><p>用来践行 Flux/Redux 的思想</p><p>看代码，公分4步走</p><p>一：创建初始值 initialState</p><p>二、创建所有操作 reducer(state, action)</p><p>三、传给 useReducer，得到读和写 API</p><p>四、调用写<code>({ type: &quot;操作类型&quot;})</code></p><p>总的来说 useReducer 是 useState 的复杂版</p><h3 id="usecontext" tabindex="-1">useContext <a class="header-anchor" href="#usecontext" aria-label="Permalink to &quot;useContext&quot;">​</a></h3><p>上下文</p><p>全局变量是全局的上下文</p><p>上下文是局部的全局变量</p><p>使用方法</p><p>一、使用 <code>const context = createContext(null)</code> 创建上下文</p>`,111)),n("p",null,[s[0]||(s[0]=t("二、使用 ")),n("code",null,"<Contet.Provider value="+h(i.state,i.setState)+">",1),s[1]||(s[1]=t(" 圈定作用域"))]),s[3]||(s[3]=a('<p>三、在作用域内使用 <code>useContext</code> 消费上下文</p><h2 id="附录-使用规则" tabindex="-1">附录：使用规则 <a class="header-anchor" href="#附录-使用规则" aria-label="Permalink to &quot;附录：使用规则&quot;">​</a></h2><p>Hooks 的本质就是 JavaScript 函数，在使用它时需要遵守<a href="https://zh-hans.reactjs.org/docs/hooks-rules.html" target="_blank" rel="noreferrer">两条规则</a></p><blockquote><h3 id="只在最顶层使用-hook" tabindex="-1">只在最顶层使用 Hook <a class="header-anchor" href="#只在最顶层使用-hook" aria-label="Permalink to &quot;只在最顶层使用 Hook&quot;">​</a></h3><p><strong>不要在循环，条件或嵌套函数中调用 Hook</strong>，确保总是在你的 React 函数的最顶层以及任何 return 之前调用他们。遵守这条规则，你就能确保 Hook 在每次渲染中都按照同样的顺序被调用。这让 React 能够在多次的 useState 和 useEffect 调用之间保持 hook 状态的正确</p><h3 id="只在-react-函数中调用-hook" tabindex="-1">只在 React 函数中调用 Hook <a class="header-anchor" href="#只在-react-函数中调用-hook" aria-label="Permalink to &quot;只在 React 函数中调用 Hook&quot;">​</a></h3><p>不要再普通的 JavaScript 函数中调用 Hook，你可以：</p><ul><li>在 React 的函数组件中调用 Hook</li><li>在自定义 Hook 中调用其他 Hook</li></ul></blockquote><h2 id="参考资料" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料" aria-label="Permalink to &quot;参考资料&quot;">​</a></h2><ul><li><p><a href="https://juejin.cn/post/6844903815762673671" target="_blank" rel="noreferrer">【React 深入】从 Mixin 到 HOC 再到 Hook</a></p></li><li><p><a href="https://overreacted.io/a-complete-guide-to-useeffect/" target="_blank" rel="noreferrer">useEffect 完整指南</a></p></li><li><p><a href="https://juejin.im/post/5dd64ae6f265da478b00e639" target="_blank" rel="noreferrer">useCallback、useMemo 分析以及差别</a></p></li><li><p><a href="https://github.com/happylindz/blog/issues/19" target="_blank" rel="noreferrer">十个案例学会 React Hooks</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/MzpUROCRYPpwOycI2sz3lQ" target="_blank" rel="noreferrer">useEffect, useCallback, useMemo 三者有何区别</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MzI1ODE4NzE1Nw==&amp;mid=2247488110&amp;idx=1&amp;sn=f7c142fb65259f22773bb2bad4ccf8ca&amp;chksm=ea0d5894dd7ad18236c174f1b5776f933473c7d6e3d3f95b3f57516d5594552ad7414198d1f4&amp;scene=126&amp;sessionid=1617017984&amp;key=74e411ceb40c53ecceeb837c57022e68713e07c93481427e7e48bce03a829b9867bfe6e59e4db1e1b7bcf1db392c63aecc4ac96c0d04c594bf4f1dcaadb7e77fc37f8e6cb0405ba447bbd29ac158bdfe5f8d98515a27c910f031d65e34617eaa75ab601ef2a0780a16db37bc7c58280e68401ba0ae105a59274bb9a0ed6d1d16&amp;ascene=1&amp;uin=MTA0NTY0NDM2MQ%3D%3D&amp;devicetype=Windows+10+x64&amp;version=62090070&amp;lang=zh_CN&amp;exportkey=ATPQQ5EDyogKCw2h%2BuLo8yA%3D&amp;pass_ticket=rOrDQ7aYmbIfx6AGR%2BUc8RcjMfmD7fSjUCfVAc87kvPd%2BMLrrXll%2BmIbzLV5R7OT&amp;wx_header=0" target="_blank" rel="noreferrer">React hooks 最佳实践【更新中】</a></p></li><li><p><a href="https://juejin.cn/post/6948748617817522206" target="_blank" rel="noreferrer">React Hooks 万字总结</a></p></li><li><p><a href="https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e" target="_blank" rel="noreferrer">React hooks: not magic, just arrays</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/-WLQPNHF2zzPB1v1Lwkw1w" target="_blank" rel="noreferrer">「React 万字基础全面剖析」</a></p></li><li><p><a href="https://felixgerschau.com/react-hooks-separation-of-concerns/" target="_blank" rel="noreferrer">Separation of concerns with React hooks</a></p></li><li><p><a href="https://www.zhihu.com/question/357020049/answer/909484669?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=56197411504128&amp;utm_content=group2_Answer&amp;utm_campaign=shareopn" target="_blank" rel="noreferrer">如何去合理使用 React hook？</a></p></li><li><p><a href="https://alexsidorenko.com/blog/react-render-always-rerenders/" target="_blank" rel="noreferrer">使用 React.memo() 提高组件性能</a></p></li></ul>',6))])}const y=l(k,[["render",r]]);export{u as __pageData,y as default};
