import{_ as a,c as i,a3 as t,o as e}from"./chunks/framework.CAwIQbWu.js";const o=JSON.parse('{"title":"ES6 面试题","description":"","frontmatter":{},"headers":[],"relativePath":"ES6/面试题/index.md","filePath":"ES6/面试题/index.md","lastUpdated":1728623095000}'),n={name:"ES6/面试题/index.md"};function l(h,s,p,r,k,d){return e(),i("div",null,s[0]||(s[0]=[t(`<h1 id="es6-面试题" tabindex="-1">ES6 面试题 <a class="header-anchor" href="#es6-面试题" aria-label="Permalink to &quot;ES6 面试题&quot;">​</a></h1><h3 id="q-箭头函数和普通函数有什么区别" tabindex="-1">Q：箭头函数和普通函数有什么区别？ <a class="header-anchor" href="#q-箭头函数和普通函数有什么区别" aria-label="Permalink to &quot;Q：箭头函数和普通函数有什么区别？&quot;">​</a></h3><ul><li>箭头函数没有自己的 this 对象，函数体内的 this 是定义时所在的对象而不是使用时所在的对象</li><li>不可以当作构造函数，也就是说，不可以对箭头函数使用 new 命令，否者会抛出一个错误</li><li>不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替（<a href="./../ES6完全指南.html">ES6 完全指南</a>）</li><li>不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数（<a href="./../Iterator&amp;Generator.html">迭代器与生成器</a>）</li></ul><h3 id="q-class-b-继承-class-a-翻译成-es5-应该是什么样子" tabindex="-1">Q： class B 继承 class A 翻译成 es5 应该是什么样子 <a class="header-anchor" href="#q-class-b-继承-class-a-翻译成-es5-应该是什么样子" aria-label="Permalink to &quot;Q： class B 继承 class A 翻译成 es5 应该是什么样子&quot;">​</a></h3><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> A</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> B</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    A</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">B</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Object.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">create</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">A</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">B</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">constructor</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> B</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><h3 id="q-为什么子类的构造函数-一定要调用super" tabindex="-1">Q: 为什么子类的构造函数，一定要调用<code>super()</code>？ <a class="header-anchor" href="#q-为什么子类的构造函数-一定要调用super" aria-label="Permalink to &quot;Q: 为什么子类的构造函数，一定要调用\`super()\`？&quot;">​</a></h3><p>A: 原因就在于 ES6 的继承机制，与 ES5 完全不同。ES5 的继承机制，是先创造一个独立的子类的实例对象，然后再将父类的方法添加到这个对象上面，即“实例在前，继承在后”。ES6 的继承机制，则是先将父类的属性和方法，加到一个空的对象上面，然后再将该对象作为子类的实例，即“继承在前，实例在后”。这就是为什么 ES6 的继承必须先调用<code>super()</code>方法，因为这一步会生成一个继承父类的<code>this</code>对象，没有这一步就无法继承父类。</p><h2 id="参考资料" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料" aria-label="Permalink to &quot;参考资料&quot;">​</a></h2><ul><li><a href="https://medium.com/starbugs/javascript-%E4%BD%A0%E5%B8%B8%E7%94%A8%E7%9A%84-array-methods-%E6%98%AF%E6%88%91%E5%B8%B8%E7%94%A8%E7%9A%84%E5%97%8E-6fe235953951" target="_blank" rel="noreferrer">JavaScript | 你常用的 Array Methods 是我常用的嗎？</a></li></ul>`,9)]))}const c=a(n,[["render",l]]);export{o as __pageData,c as default};
