import{_ as e,c as r,a3 as l,o as t}from"./chunks/framework.CAwIQbWu.js";const p=JSON.parse('{"title":"渲染进程中的线程","description":"","frontmatter":{},"headers":[],"relativePath":"Browser/渲染进程中的线程.md","filePath":"Browser/渲染进程中的线程.md","lastUpdated":1718689615000}'),i={name:"Browser/渲染进程中的线程.md"};function o(h,a,n,s,d,c){return t(),r("div",null,a[0]||(a[0]=[l('<h1 id="渲染进程中的线程" tabindex="-1">渲染进程中的线程 <a class="header-anchor" href="#渲染进程中的线程" aria-label="Permalink to &quot;渲染进程中的线程&quot;">​</a></h1><h2 id="写在面前" tabindex="-1">写在面前 <a class="header-anchor" href="#写在面前" aria-label="Permalink to &quot;写在面前&quot;">​</a></h2><p>上一章我们介绍了 <a href="./浏览器架构.html">浏览器架构</a> 。介绍了现代浏览器的架构为多进程架构，它由浏览器主进程、GPU 进程、网络进程、音频进程、存储进程、多个渲染进程和多个插件进程组成（89.0.4389.90 版本 Chrome）。我们也说了线程的崩坏会导致页面（渲染进程）卡死，但不会影响其他页面。</p><p>那么渲染进程有什么组成？这个很重要，因为它是页面渲染、事件循环的基础。</p><h2 id="一句话解释" tabindex="-1">一句话解释 <a class="header-anchor" href="#一句话解释" aria-label="Permalink to &quot;一句话解释&quot;">​</a></h2><p>渲染进程就是我们常说的浏览器内核，负责页面渲染，脚本执行，事件处理等，每个 tab 页就是一个渲染进程</p><p>渲染进程中包括 GUI 渲染线程、 JS 引擎线程、事件触发线程、网络异步线程、定时器线程</p><p>渲染进程内部包含主线程、工作线程、合成线程和光栅线程</p><h2 id="由什么组成" tabindex="-1">由什么组成 <a class="header-anchor" href="#由什么组成" aria-label="Permalink to &quot;由什么组成&quot;">​</a></h2><h3 id="gui-渲染线程" tabindex="-1">GUI 渲染线程 <a class="header-anchor" href="#gui-渲染线程" aria-label="Permalink to &quot;GUI 渲染线程&quot;">​</a></h3><ul><li>负责渲染浏览器界面，解析 HTML、CSS，构建 DOM 树和 RenderObject 树，布局和绘制等</li><li>当界面需要重绘或由于某种操作引发回流时，该线程就会执行</li><li>注意，<strong>GUI 渲染线程与 JS 引擎线程时互斥</strong>，当 JS 引擎执行时 GUI 线程会被挂在，GUI 更新会被保存在一个队列中等待 JS 引擎空闲时立即被执行</li></ul><h3 id="js-引擎线程" tabindex="-1">JS 引擎线程 <a class="header-anchor" href="#js-引擎线程" aria-label="Permalink to &quot;JS 引擎线程&quot;">​</a></h3><ul><li>也称为 JS 内核，负责处理 JavaScript 脚本程序（例如 V8 引擎）</li><li>负责处理解析和执行 JavaScript 脚本程序</li><li>只有一个 JS 引擎线程（单线程）</li><li><strong>与 GUI 渲染线程互斥</strong>，防止渲染结果不可预期</li></ul><h3 id="事件触发线程" tabindex="-1">事件触发线程 <a class="header-anchor" href="#事件触发线程" aria-label="Permalink to &quot;事件触发线程&quot;">​</a></h3><ul><li>用来控制事件循环（鼠标点击、setTimeout、Ajax 等）</li><li>当事件满足触发条件时，将事件放入到 JS 引擎所在的执行队列中</li><li>归属于浏览器而不是<code>JS</code>引擎，用来控制事件循环</li></ul><h3 id="定时触发器线程" tabindex="-1">定时触发器线程 <a class="header-anchor" href="#定时触发器线程" aria-label="Permalink to &quot;定时触发器线程&quot;">​</a></h3><ul><li><code>setTimeout</code>和<code>setInterval</code>所在的线程</li><li>定时任务并不是由 JS 引擎计时的，是由定时触发线程来计时</li><li>计时完毕后，通知事件触发线程</li></ul><h3 id="异步-http-请求线程" tabindex="-1">异步 HTTP 请求线程 <a class="header-anchor" href="#异步-http-请求线程" aria-label="Permalink to &quot;异步 HTTP 请求线程&quot;">​</a></h3><ul><li>浏览器有一个单独的线程用于处理 AJAX 请求</li><li>当请求完成时，若有回调函数，通知事件触发线程</li></ul><h3 id="为什么-gui-渲染线程与-js-引擎线程互斥" tabindex="-1">为什么 GUI 渲染线程与 JS 引擎线程互斥 <a class="header-anchor" href="#为什么-gui-渲染线程与-js-引擎线程互斥" aria-label="Permalink to &quot;为什么 GUI 渲染线程与 JS 引擎线程互斥&quot;">​</a></h3><p>这是由于 JS 是可以操作 DOM 的，如果同时修改元素属性并同时渲染界面（即 JS 线程 和 UI 线程同时运行），那么渲染线程前后获得的元素就可能不一致了</p><h2 id="js阻塞页面加载以及-react-fiber-架构的出现" tabindex="-1">JS阻塞页面加载以及 React Fiber 架构的出现 <a class="header-anchor" href="#js阻塞页面加载以及-react-fiber-架构的出现" aria-label="Permalink to &quot;JS阻塞页面加载以及 React Fiber 架构的出现&quot;">​</a></h2><p>因为 GUI 渲染线程和 JS 引擎线程是互斥的，所以如果 JS 执行时间过长就会出现页面卡顿现象</p><p>比如 React15 采用的递归更新，当组件过大时，意味着JS引擎线程需要花很多时间去执行，这样导致 GUI 不能绘制页面，不能绘制页面就呈现卡顿现象</p><p>所以才有了后面的 React Fiber 架构，采用时间分片才解决大组件更新问题</p><h2 id="webworker" tabindex="-1">WebWorker <a class="header-anchor" href="#webworker" aria-label="Permalink to &quot;WebWorker&quot;">​</a></h2><p>我们讲到 JS 引擎是单线程，当 JS 执行时间很长时，页面无法得到响应体检变差，那么解决方案是什么？</p><p>HTML5 提出了 Web Worker，浏览器提供给了一个子线程，让其可以与 JS 引擎相互通信</p><p>所以，当有比较耗时的工作，就可以单独开一个 Worker 线程，待计算出结果后，将结果通信给 JS 引擎线程即可（通过 postMessage API）</p><p>除了 WebWorker 外，还有 SharedWorker，两者的区别在于：</p><ul><li>WebWorker 只负责某个页面，它相当于是某个渲染进程（一个页面就是一个渲染进程）下的一个线程</li><li>SharedWorker 是浏览器所有页面共享的（由单独的进程管理，与渲染进程一个级别）</li></ul><h2 id="参考资料" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料" aria-label="Permalink to &quot;参考资料&quot;">​</a></h2><ul><li><p><a href="https://segmentfault.com/a/1190000014018604" target="_blank" rel="noreferrer">浏览器渲染机制</a></p></li><li><p><a href="https://juejin.cn/post/6844903919789801486#heading-5" target="_blank" rel="noreferrer">「前端进阶」从多线程到 Event Loop 全面梳理</a></p></li></ul>',33)]))}const b=e(i,[["render",o]]);export{p as __pageData,b as default};
