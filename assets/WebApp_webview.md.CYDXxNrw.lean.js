import{_ as a,c as i,a3 as p,o as r}from"./chunks/framework.CAwIQbWu.js";const w=JSON.parse('{"title":"webview","description":"","frontmatter":{},"headers":[],"relativePath":"WebApp/webview.md","filePath":"WebApp/webview.md","lastUpdated":1647415462000}'),t={name:"WebApp/webview.md"};function h(o,e,b,l,d,n){return r(),i("div",null,e[0]||(e[0]=[p('<h1 id="webview" tabindex="-1">webview <a class="header-anchor" href="#webview" aria-label="Permalink to &quot;webview&quot;">​</a></h1><p>webview 的原理</p><p>如何实现 webview</p><h4 id="hybrid-是什么-为何会是用-hybrid" tabindex="-1">hybrid 是什么，为何会是用 hybrid？ <a class="header-anchor" href="#hybrid-是什么-为何会是用-hybrid" aria-label="Permalink to &quot;hybrid 是什么，为何会是用 hybrid？&quot;">​</a></h4><p>hybrid 即“混合”，即前端和客户端的混合开发</p><p>需要前端开发人员和客户端开发人员配合完成</p><p>某些环节也可能涉及到 server 端</p><h5 id="存在价值" tabindex="-1">存在价值 <a class="header-anchor" href="#存在价值" aria-label="Permalink to &quot;存在价值&quot;">​</a></h5><p>可以快速迭代更新【关键】（无需 app 审核）</p><h4 id="webview-1" tabindex="-1">webview <a class="header-anchor" href="#webview-1" aria-label="Permalink to &quot;webview&quot;">​</a></h4><p>是 app 中的一个组件（app 可以有 webview，也可以不要）</p><p>用于加载 h5 页面，即一个小型的浏览器内核</p><h4 id="file-协议" tabindex="-1">file 协议 <a class="header-anchor" href="#file-协议" aria-label="Permalink to &quot;file 协议&quot;">​</a></h4><p>https 协议（远程的），file 协议（文件协议，加载本地的）</p><p>file 协议：本地文件，快</p><p>http(s)协议：网络加载，慢</p><h4 id="具体实现" tabindex="-1">具体实现： <a class="header-anchor" href="#具体实现" aria-label="Permalink to &quot;具体实现：&quot;">​</a></h4><p>前端做好页面，客户端开启 webview，用 file 协议加载静态页面</p><h4 id="完整流程" tabindex="-1">完整流程 <a class="header-anchor" href="#完整流程" aria-label="Permalink to &quot;完整流程&quot;">​</a></h4><p>分版本号</p><p>将静态文件压缩成 zip 包，上传到服务端</p><p>客户端每次启动，都去服务端检查版本号</p><p>如果服务端版本号与客户端不同，就去下载最新的包</p><p>下载完之后解压包，然后将现有文件覆盖</p><p>hybrid 和 H5 的区别</p><p>优点：体验更好，更 NA 体验基本一致</p><p>可快速迭代，无需 app 审核【关键】</p><p>缺点：开发成本高。联调、测试、查 bug 比较麻烦</p><p>运维成本高</p>',29)]))}const c=a(t,[["render",h]]);export{w as __pageData,c as default};
