import{_ as a,c as t,a3 as r,o as i}from"./chunks/framework.CAwIQbWu.js";const h=JSON.parse('{"title":"Diff 算法","description":"","frontmatter":{},"headers":[],"relativePath":"React/Diff.md","filePath":"React/Diff.md","lastUpdated":1718068265000}'),f={name:"React/Diff.md"};function l(o,e,n,p,s,d){return i(),t("div",null,e[0]||(e[0]=[r('<h1 id="diff-算法" tabindex="-1">Diff 算法 <a class="header-anchor" href="#diff-算法" aria-label="Permalink to &quot;Diff 算法&quot;">​</a></h1><p>对比 Diff 的话，最初的算法时间复杂度为 O(n3)</p><p>React 在以下两个假设的基础上提出了一套 O(n) 的启发式算法</p><ol><li>两个不同类型的元素会产生不同的树</li><li>对于同一层级的子节点，可以通过 key 属性进行唯一标识。通过给子节点添加唯一 key 值，React 可以快速定位到发生变化的节点，而不需要对整个子树进行 diff</li></ol><p>完全对比 O(n3)无法接受，故降级为同层对比的 O(n)方案</p><p>为什么降级可行？因为跨层级很少发生可以忽略</p><h3 id="virtualdom-diff-算法" tabindex="-1">VirtualDOM Diff 算法 <a class="header-anchor" href="#virtualdom-diff-算法" aria-label="Permalink to &quot;VirtualDOM Diff 算法&quot;">​</a></h3><p>一般的设计思路都是页面等于页面状态的映射，即 UI = render(state)。当需要更新页面的时候，无需关系 DOM 具体的变换方式，只需要改变 state 即可，剩下的事情（render）将由框架代劳。</p><p>所以思路就是改变 state，生成新的 VD - 新的 VD 与旧的 VD 进行对比 - 生成差异对象（patch） - 遍历差异对象并更新</p><p>patch(container, vnode) 第一次渲染</p><p>patch(vnode, newVnode) 更新数据</p><h2 id="参考资料" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料" aria-label="Permalink to &quot;参考资料&quot;">​</a></h2><ul><li><p><a href="https://mp.weixin.qq.com/s/XRR9afpujcjbgFZM0Zw6Gw" target="_blank" rel="noreferrer">DIff 算法看不懂就一起来锤我(带图)</a></p></li><li><p><a href="https://juejin.cn/post/6994959998283907102" target="_blank" rel="noreferrer">15 张图，20 分钟吃透 Diff 算法核心原理</a></p></li><li><p><a href="https://github.com/ascoders/weekly/blob/v2/190.%E7%B2%BE%E8%AF%BB%E3%80%8ADOM%20diff%20%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3%E3%80%8B.md" target="_blank" rel="noreferrer">精读《DOM diff 原理详解》</a></p></li><li><p><a href="https://zh-hans.reactjs.org/docs/reconciliation.html#gatsby-focus-wrapper" target="_blank" rel="noreferrer">协调</a></p></li></ul>',13)]))}const u=a(f,[["render",l]]);export{h as __pageData,u as default};
