import{_ as a,c as i,a3 as e,o as t}from"./chunks/framework.CAwIQbWu.js";const k=JSON.parse('{"title":"页面渲染层面","description":"","frontmatter":{},"headers":[],"relativePath":"Performance/页面渲染层面优化.md","filePath":"Performance/页面渲染层面优化.md","lastUpdated":1722850347000}'),n={name:"Performance/页面渲染层面优化.md"};function l(p,s,r,h,d,o){return t(),i("div",null,s[0]||(s[0]=[e(`<h1 id="页面渲染层面" tabindex="-1">页面渲染层面 <a class="header-anchor" href="#页面渲染层面" aria-label="Permalink to &quot;页面渲染层面&quot;">​</a></h1><p>渲染时机相关</p><p>懒加载</p><p>懒执行</p><p>渐进式渲染</p><p>html dom 树，css cssom 树 defer async 等等 遇到 js，preload 以及 prefetch 并发加载 重绘和回流 浏览器缓存</p><p>页面渲染阶段</p><ul><li>css 在上、js 在下</li><li>加载 css 推荐用 link 少用 @import <ul><li>link 属于 html，@import 属于 css，需写在样式表开头</li><li>@import 是 css2.1 才出现的概念</li><li>当 html 文件被加载时，link 引用的文件会同时被加载，而@import 引用的文件则会等页面全部下载完毕再被加载</li></ul></li><li>不重要的外置引入的 js 使用 defer 或者 async 属性异步加载</li></ul><p><code>script</code> 特性（attribute）可以为我们解决延迟问题：<code>defer</code> 和 <code>async</code></p><h3 id="defer" tabindex="-1">defer <a class="header-anchor" href="#defer" aria-label="Permalink to &quot;defer&quot;">​</a></h3><p><code>defer</code> 特性告诉浏览器不要等待脚本。相反，浏览器将继续处理 HTML，构建 DOM。脚本会“在后台”下载，然后等 DOM 构建完成后，脚本才会执行</p><p>换句话说：</p><ul><li>具有 <code>defer</code> 特性的脚本不会阻塞页面</li><li>具有 <code>defer</code> 特性的脚本总是要等到 DOM 解析完毕，但在 <code>DOMContentLoaded</code> 事件之前执行</li></ul><p>下面这个示例演示了上面所说的第二句话：</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;...content before scripts...&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;DOMContentLoaded&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        alert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;DOM ready after defer!&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    defer</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;https://javascript.info/article/script-async-defer/long.js?speed=1&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;...content after scripts...&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><ol><li>页面内容立即显示</li><li><code>DOMContentLoaded</code> 事件处理程序等待具有<code>defer</code> 特性的脚本执行完成。它仅在脚本下载且执行结束后才会被触发</li></ol><p><strong>具有 <code>defer</code> 特性的脚本保持其相对顺序，就像常规脚本一样。</strong></p><p><strong><code>defer</code> 特性仅适用于外部脚本</strong></p><p>如果 <code>&lt;script&gt;</code> 脚本没有 <code>src</code>，则会忽略 <code>defer</code> 特性。</p><h3 id="async" tabindex="-1">async <a class="header-anchor" href="#async" aria-label="Permalink to &quot;async&quot;">​</a></h3><p><code>async</code> 特性与 <code>defer</code> 有些类似。它也能够让脚本不阻塞页面，但是，在行为上二者有着重要的区别</p><p><code>async</code> 特性意味着脚本是完成独立的</p><ul><li>浏览器不会因 <code>async </code> 脚本而阻塞（与 <code>defer</code> 类似）</li><li>其他脚本不会等待 <code>async</code> 脚本加载完成，同样，<code>async</code> 脚本也不会等待其他脚本</li><li><code>DOMContentLoaded</code> 可能会发生在异步脚本之前（如果异步脚本在页面完成后才加载完成）</li><li><code>DOMContentLoaded</code> 也可能发生在异步脚本之后（如果异步脚本很短，或者是从 HTTP 缓存中加载的）</li></ul><p>换句话说，<code>async</code> 脚本会在后台加载，并在加载就绪时运行。DOM 和其他脚本不会等待它们，它们也不会等待其他的东西。<code>async</code> 脚本就是一个会在加载完成时执行的完全独立的脚本</p><h3 id="动态脚本" tabindex="-1">动态脚本 <a class="header-anchor" href="#动态脚本" aria-label="Permalink to &quot;动态脚本&quot;">​</a></h3><p>我们可以使用 JavaScript 动态地创建一个脚本，并将其插入（append）到文档（document）中：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> script </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;script&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">script.src </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;/article/script-async-defer/long.js&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">document.body.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">append</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(script); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// (*)</span></span></code></pre></div><p><strong>默认情况下，动态脚本的行为是“异步”的。</strong></p><p>也就是说：</p><ul><li>它们不会等待任何东西，也没有上面东西会等它们</li><li>先加载完成的脚本先执行（“加载优先”顺序）</li></ul><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p><code>async</code> 和 <code>defer</code> 有一个共同点：加载这样的脚本都不会阻塞页面的渲染。因此，用户可以立即圆度并了解页面内容。但是，它们之前也存在一些本质的区别：</p><table tabindex="0"><thead><tr><th></th><th>顺序</th><th>DOMContnetLoaded</th></tr></thead><tbody><tr><td>async</td><td>加载优先顺序。脚本在文档中的顺序不重要——先加载完成的先执行</td><td>不相关。可能在文档加载完成前加载并执行完毕。如果脚本很小或者来自缓存，同时文档足够长，就会发生这种情况</td></tr><tr><td>defer</td><td>文档顺序（它们在文档中的顺序）</td><td>在文档加载和解析完成之后（如果需要，则会等待），即在<code>DOMContentLoaded</code> 之前执行</td></tr></tbody></table><p>在实际开发中，<code>defer</code> 用于需要整个 DOM 的脚本，脚本的相对执行顺序很重要的时候使用</p><p><code>async</code> 用于独立脚本，例如计数器或广告，这些脚本的相对执行顺序无关紧要</p><h2 id="浏览器渲染原理" tabindex="-1">浏览器渲染原理 <a class="header-anchor" href="#浏览器渲染原理" aria-label="Permalink to &quot;浏览器渲染原理&quot;">​</a></h2><p>async / defer</p><p>实际工作中，用 defer，async 用的很少</p><p>JS 的下载和执行会阻塞 HTML 解析</p><p>CSS 的下载和执行会阻塞 JS 执行</p><h3 id="页面渲染" tabindex="-1">页面渲染 <a class="header-anchor" href="#页面渲染" aria-label="Permalink to &quot;页面渲染&quot;">​</a></h3><p>DOM树</p><p>CSS 树</p><p>合成为渲染树</p><p>布局（Layout）：大小、尺寸</p><ul><li>reflow（回流）</li></ul><p>绘制（Paint）：颜色、阴影</p><ul><li>repaint（重绘）</li></ul><p>合成（Composite）：层次</p><p><a href="https://csstriggers.com" target="_blank" rel="noreferrer">https://csstriggers.com</a></p><h2 id="代码优化技巧" tabindex="-1">代码优化技巧 <a class="header-anchor" href="#代码优化技巧" aria-label="Permalink to &quot;代码优化技巧&quot;">​</a></h2><h3 id="动态导入" tabindex="-1">动态导入 <a class="header-anchor" href="#动态导入" aria-label="Permalink to &quot;动态导入&quot;">​</a></h3><p>suspense，lazy</p><p>lazy 传入</p><h3 id="懒加载" tabindex="-1">懒加载 <a class="header-anchor" href="#懒加载" aria-label="Permalink to &quot;懒加载&quot;">​</a></h3><p>对于 js，叫动态引入</p><p>对于图片，叫懒加载</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;img src =&quot;product.jpg&quot; /&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>&lt;img src=&quot;placeholder.png&quot; data-src=&quot;product.jpg&quot; /&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 伪代码</span></span>
<span class="line"><span>window on scroll</span></span>
<span class="line"><span>	findImgs().each img</span></span>
<span class="line"><span>		new Image()</span></span>
<span class="line"><span>			.src = img.dataset.src</span></span>
<span class="line"><span>			.onload img.src = img.dataset.src</span></span></code></pre></div><p>预加载：在快加载前先加载</p><h3 id="css-代码优化技巧" tabindex="-1">CSS 代码优化技巧 <a class="header-anchor" href="#css-代码优化技巧" aria-label="Permalink to &quot;CSS 代码优化技巧&quot;">​</a></h3><p>删除无用CSS</p><p>使用更高效的选择器</p><p>减少重排（reflow/relayout）</p><p>不要使用 @import url.css</p><p>启动 GPU 硬件加速：transform: translate3d(0,0,0)</p><p>使用缩写（#FFFFFF =&gt; #FFF; 0.1 =&gt;.1 0px =&gt;0）</p><p>砍需求</p><h4 id="js代码优化技巧" tabindex="-1">JS代码优化技巧 <a class="header-anchor" href="#js代码优化技巧" aria-label="Permalink to &quot;JS代码优化技巧&quot;">​</a></h4><p>尽量不要全局变量：因为全局变量太多会使变量查找变慢</p><p>尽量少操作DOM：可以使用 Fragment 一次性插入多个 DOM 节点</p><p>不要往页面中插入大量的 HTML：一定会卡</p><ul><li>Fiber 就是因为之前 React 会递归循环卡顿才提出的</li><li>使用 requestAnimateFrame 做时间切片</li></ul><p>尽量少触发重排：可以使用节流和防抖来降低重排频率</p><p>尽量少用闭包，避免内存泄露：实际上是浏览器的bug</p><p>面试专用：使用虚拟滚动列表</p><h5 id="使用虚拟滚动列表" tabindex="-1">使用虚拟滚动列表 <a class="header-anchor" href="#使用虚拟滚动列表" aria-label="Permalink to &quot;使用虚拟滚动列表&quot;">​</a></h5><p>十万条数据的问题</p><p>最好的方法是分页</p><p>按需渲染</p><p>代码优化</p><ul><li>loading/骨架屏</li><li>web worker</li><li>虚拟列表</li><li>懒加载</li><li>dom/style 批量更新</li></ul><h2 id="动画性能优化" tabindex="-1">动画性能优化 <a class="header-anchor" href="#动画性能优化" aria-label="Permalink to &quot;动画性能优化&quot;">​</a></h2><h2 id="参考资料" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料" aria-label="Permalink to &quot;参考资料&quot;">​</a></h2><h2 id="参考资料-1" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料-1" aria-label="Permalink to &quot;参考资料&quot;">​</a></h2><ul><li><a href="https://zh.javascript.info/script-async-defer" target="_blank" rel="noreferrer">脚本：async，defer</a></li><li><a href="https://github.com/amfe/article/issues/47#" target="_blank" rel="noreferrer">CSS Animation 性能优化</a></li><li><a href="https://zhuanlan.zhihu.com/p/458424384" target="_blank" rel="noreferrer">从浏览器渲染原理谈动画性能优化</a></li></ul>`,85)]))}const E=a(n,[["render",l]]);export{k as __pageData,E as default};
