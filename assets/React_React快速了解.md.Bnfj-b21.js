import{_ as e,c as i,a3 as t,o as s}from"./chunks/framework.CAwIQbWu.js";const k=JSON.parse('{"title":"React 快速了解","description":"","frontmatter":{},"headers":[],"relativePath":"React/React快速了解.md","filePath":"React/React快速了解.md","lastUpdated":1729427485000}'),l={name:"React/React快速了解.md"};function r(p,a,n,h,o,c){return s(),i("div",null,a[0]||(a[0]=[t(`<h1 id="react-快速了解" tabindex="-1">React 快速了解 <a class="header-anchor" href="#react-快速了解" aria-label="Permalink to &quot;React 快速了解&quot;">​</a></h1><h2 id="是什么" tabindex="-1">是什么 <a class="header-anchor" href="#是什么" aria-label="Permalink to &quot;是什么&quot;">​</a></h2><p>用于构建用户界面的 JavaScript 库</p><p>meta 做的一个 UI 库</p><p>React 英语意思：响应</p><h2 id="特点" tabindex="-1">特点 <a class="header-anchor" href="#特点" aria-label="Permalink to &quot;特点&quot;">​</a></h2><p>声明式</p><p>组件化</p><p>一次学习，跨平台编写</p><p>最好的学习资料在<a href="https://zh-hans.react.dev/" target="_blank" rel="noreferrer">官网</a></p><p>Redux 的作者的 <a href="https://overreacted.io/" target="_blank" rel="noreferrer">博客</a> ，上面有很多易错点以及原理解答，很好的学习资料</p><h2 id="哲学" tabindex="-1">哲学 <a class="header-anchor" href="#哲学" aria-label="Permalink to &quot;哲学&quot;">​</a></h2><p>单向数据流</p><p>不可变特性（immutability）</p><h2 id="本质" tabindex="-1">本质 <a class="header-anchor" href="#本质" aria-label="Permalink to &quot;本质&quot;">​</a></h2><p>主要有三个特征</p><ul><li><p>UI = f(data)</p><ul><li>贯彻了一套公式</li><li>改变 data，驱动 function，从而改变 UI <ul><li>data 即我们所说的 props 和 state</li></ul></li></ul></li><li><p>一切都是组件</p><ul><li>页面是组件，路由也是组件，错误边界也是组件...</li></ul></li><li><p>声明式编程</p><ul><li>对比 JQuery <ul><li>JQuery 是命令式的库，直接操作 dom，我拿到这个 dom，我要去干什么</li><li>React 是声明式的库，写好一个组件，UI 就展示成什么样</li></ul></li></ul></li></ul><h2 id="执行过程" tabindex="-1">执行过程 <a class="header-anchor" href="#执行过程" aria-label="Permalink to &quot;执行过程&quot;">​</a></h2><p>我们用 JSX 来写 React，JSX 会通过 babel 将其代码转换成 React.createElement 的形式，React.createElement 返回的是一个对 DOM 的描述，并不是真正的 DOM，这个叫 Virtual DOM</p><p>当某一时刻调用 React 的 <code>render()</code> 方法，会创建一颗由 React 元素组成的树，在下一次 props 或 state 更新时，相同的 <code>render()</code> 方法会返回一颗不同的树。React 需要基于这两颗树之间的差异来判断如何高效更新 UI，这也就是 Diff</p><p>说到 Diff，此概念在 <a href="./../Git/">Git</a> 中也有过，不过 Diff 的算法与 React 不同，在 Git 中时间复杂度为 O(n2)，但是在 React 里，最优的算法的时间复杂度仍为 O(n3)</p><p>所以 React 在以下两个假设的基础上提出了一套 O(n) 的启发式算法</p><ol><li>两个不同类型的元素会产生出不同的树</li><li>开发者可以通过设置 key 属性，来告知渲染哪些子元素在不同的渲染树下可以保持不变</li></ol><p>其第一点，不同类型的元素会产生不同的树，React 发现组件的类型不同时，直接重绘新的组件，而不去在做 Diff。第二点即可理解为动态产生的组件需要设置 key</p><h3 id="render" tabindex="-1">Render <a class="header-anchor" href="#render" aria-label="Permalink to &quot;Render&quot;">​</a></h3><p>Class 中的 Render 方法是个纯函数，不做任何直接渲染的事情。只是返回了一些指令，由 React 对这些指令做真正的 DOM 操作</p><p>JSX 其实是 <code>React.createElement(component, props,...children)</code> 函数的语法糖。如下 JSX 代码：</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MyButton</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> color</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;blue&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> shadowSize</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Click Me</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MyButton</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>会编译为：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">React.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(MyButton, { color: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;blue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, shadowSize: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Click Me&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p><a href="https://babeljs.io/repl/#?browsers=defaults%2C%20not%20ie%2011%2C%20not%20ie_mob%2011&amp;build=&amp;builtIns=false&amp;corejs=3.6&amp;spec=false&amp;loose=false&amp;code_lz=GYVwdgxgLglg9mABACwKYBt1wBQEpEDeAUIogE6pQhlIA8AJjAG4B8AEhlogO5xnr0AhLQD0jVgG4iAXyJA&amp;debug=false&amp;forceAllTransforms=false&amp;shippedProposals=false&amp;circleciRepo=&amp;evaluate=false&amp;fileSize=false&amp;timeTravel=false&amp;sourceType=module&amp;lineWrap=true&amp;presets=react&amp;prettier=false&amp;targets=&amp;version=7.15.5&amp;externalPlugins=&amp;assumptions=%7B%7D" target="_blank" rel="noreferrer">在线 Babel 编译器</a> 可以玩一玩</p><h2 id="参考资料" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料" aria-label="Permalink to &quot;参考资料&quot;">​</a></h2><ul><li><a href="https://zh-hans.reactjs.org" target="_blank" rel="noreferrer">React 官网</a></li><li><a href="https://www.zhihu.com/lives/883022235516960768" target="_blank" rel="noreferrer">帮助你深入理解 React</a></li><li><a href="https://www.xbroder.com/2018/08/19/react-zhihu-live/" target="_blank" rel="noreferrer">Live - 帮助你深入理解 React</a></li></ul>`,33)]))}const u=e(l,[["render",r]]);export{k as __pageData,u as default};
