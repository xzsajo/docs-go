import{_ as i,c as a,a3 as l,o as n}from"./chunks/framework.CAwIQbWu.js";const g=JSON.parse('{"title":"模拟题一","description":"","frontmatter":{},"headers":[],"relativePath":"Interview/book1.md","filePath":"Interview/book1.md","lastUpdated":1736435697000}'),h={name:"Interview/book1.md"};function t(p,s,e,k,r,E){return n(),a("div",null,s[0]||(s[0]=[l(`<h1 id="模拟题一" tabindex="-1">模拟题一 <a class="header-anchor" href="#模拟题一" aria-label="Permalink to &quot;模拟题一&quot;">​</a></h1><h2 id="_1-css-bfc-是什么" tabindex="-1">1. CSS：BFC 是什么 <a class="header-anchor" href="#_1-css-bfc-是什么" aria-label="Permalink to &quot;1. CSS：BFC 是什么&quot;">​</a></h2><p>一句话解释：BFC 是块级格式化上下文，它的作用有清除内部浮动、margin 塌陷、垂直 margin 合并、自适应布局，可通过<code>overflow: hidden</code> 等方法触发</p><h3 id="文档流" tabindex="-1">文档流 <a class="header-anchor" href="#文档流" aria-label="Permalink to &quot;文档流&quot;">​</a></h3><p>文档流分 定位流、浮动流、普通流</p><p>BFC 属于普通流，其他的有</p><ul><li>IFC：行级格式化上下文， inline 内联</li><li>GFC：网格布局格式化上下文，display: grid</li><li>FFC：自适应格式化上下文， display: flex，或 display: inline-flex</li></ul><h3 id="bfc-是什么" tabindex="-1">BFC 是什么 <a class="header-anchor" href="#bfc-是什么" aria-label="Permalink to &quot;BFC 是什么&quot;">​</a></h3><p>块级格式化上下文，是块级盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域</p><p>具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性</p><p>通俗讲：BFC 是一个封闭的大箱子，箱子内部无论如何折腾，就不会影响到外部</p><h3 id="如何触发-bfc" tabindex="-1">如何触发 BFC <a class="header-anchor" href="#如何触发-bfc" aria-label="Permalink to &quot;如何触发 BFC&quot;">​</a></h3><ul><li>根元素（html）</li><li>浮动元素（float 的值不为 none 的元素）</li><li>绝对定位元素（position 的值为 absolute 或 fixed 的元素）</li><li>行内块元素（display 的值为 inline-block 的元素）</li><li>表格单元格（display 的值为 table-cell，HTML 表格单元格默认值）</li><li>表格标题（display 的值为 table-caption，HTML 表格标题默认值）</li><li>overflow 的值不为 visible 或 clip 块级元素</li><li>弹性元素（display 的值为 flex 或 inline-flex 元素的直接子元素）</li><li>网格元素（display 的值为 grid 或 inline-grid 元素的直接子元素）</li></ul><p>详见：<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_display/Block_formatting_context" target="_blank" rel="noreferrer">MDN</a></p><h3 id="bfc的特征" tabindex="-1">BFC的特征 <a class="header-anchor" href="#bfc的特征" aria-label="Permalink to &quot;BFC的特征&quot;">​</a></h3><ul><li>BFC 是页面上的一个独立容器，容器里面的元素不会影响外面的元素</li><li>BFC 内部的块级盒会在垂直方向上一个接一个排列</li><li>同一 BFC 下的相领块级元素可能发生外边距重叠，创建新的 BFC 可以避免外边距重叠</li><li>每个元素的外边距盒（margin box）的左边与包含块边框盒（border box）的左边相接触（从右向左的格式的话，则相反），即使存在浮动</li><li>浮动盒的区域不会和 BFC 重叠</li><li>计算 BFC 的高度时，浮动元素也会参与计算</li></ul><h3 id="bfc-有什么用" tabindex="-1">BFC 有什么用 <a class="header-anchor" href="#bfc-有什么用" aria-label="Permalink to &quot;BFC 有什么用&quot;">​</a></h3><ul><li>修复浮动元素造成的高度塌陷问题 <ul><li>子元素浮动，引起高度为0，父元素加上 BFC（overflow: hidden），撑起高度</li></ul></li><li>margin 塌陷</li><li>垂直 margin 合并</li><li>实现灵活健壮的自适应布局</li></ul><p>相关文章：<a href="https://docs-go.vercel.app/Basic/CSS/BFC%E6%98%AF%E4%BB%80%E4%B9%88.html" target="_blank" rel="noreferrer">CSS 世界中的结界——BFC</a></p><h2 id="_2-手写源码-防抖与节流" tabindex="-1">2. 手写源码：防抖与节流 <a class="header-anchor" href="#_2-手写源码-防抖与节流" aria-label="Permalink to &quot;2. 手写源码：防抖与节流&quot;">​</a></h2><h3 id="防抖" tabindex="-1">防抖 <a class="header-anchor" href="#防抖" aria-label="Permalink to &quot;防抖&quot;">​</a></h3><p>无论触发多少次，一定在事件触发后的 n 秒后执行，如果你在一个事件触发 n 秒内又触发了这个事件，以新的事件的时间为准，n 秒后再执行。总之，触发事件 n 秒内不再触发事件，n 秒后再执行</p><h4 id="应用场景" tabindex="-1">应用场景 <a class="header-anchor" href="#应用场景" aria-label="Permalink to &quot;应用场景&quot;">​</a></h4><ul><li>调整浏览器窗口大小</li><li>搜索框输入（输入后 1000 毫秒搜索）</li><li>表单验证（输入 1000 毫秒后验证）</li></ul><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> debounce</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">func</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">wait</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">flag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> timer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        clearTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(timer);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">timer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> flag) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            func.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">apply</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, args);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        timer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            func.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">apply</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, args);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }, wait);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// flag 是否立即执行</span></span></code></pre></div><h3 id="节流" tabindex="-1">节流 <a class="header-anchor" href="#节流" aria-label="Permalink to &quot;节流&quot;">​</a></h3><p>不管事件触发频率多高，只在单位时间内执行一次</p><h4 id="应用场景-1" tabindex="-1">应用场景 <a class="header-anchor" href="#应用场景-1" aria-label="Permalink to &quot;应用场景&quot;">​</a></h4><ul><li>滚动监控（计算位置信息）</li><li>周期性事件（比如每隔一段时间更新页面数据）</li><li>无限滚动加载</li></ul><h4 id="实现方法" tabindex="-1">实现方法 <a class="header-anchor" href="#实现方法" aria-label="Permalink to &quot;实现方法&quot;">​</a></h4><p>时间戳/定时器</p><p>时间戳：第一次肯定触发，最后一次不执行</p><p>定时器：第一次不执行，最后一次肯定触发</p><h5 id="时间戳" tabindex="-1">时间戳 <a class="header-anchor" href="#时间戳" aria-label="Permalink to &quot;时间戳&quot;">​</a></h5><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> throttle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">func</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">wait</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pre </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (Date.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">now</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pre </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> wait) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            pre </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Date.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">now</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            func.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">apply</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, args);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h5 id="定时器" tabindex="-1">定时器 <a class="header-anchor" href="#定时器" aria-label="Permalink to &quot;定时器&quot;">​</a></h5><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> throttle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">func</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">wait</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> timer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">timer) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            timer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                timer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                func.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">apply</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, args);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }, wait);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>结合版本，第一次和最后一次都会触发</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> throttle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">func</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">wait</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pre </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        timer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (Date.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">now</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pre </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> wait) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            clearTimeot</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(timer);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            timer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            pre </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Date.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">now</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            func.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">apply</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, args);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">timer) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            timer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                func.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">apply</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, args);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }, wait);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>衍生问题：手写apply、箭头函数和普通函数有什么区别、数组和类数组的区别</p><h3 id="手写-apply" tabindex="-1">手写 apply <a class="header-anchor" href="#手写-apply" aria-label="Permalink to &quot;手写 apply&quot;">​</a></h3><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> myApply</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> window, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> undefined</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fn </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Symbol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    context[fn] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (Array.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(args)) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> context[fn](</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">args);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> context[fn]();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    delete</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> context[fn];</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="箭头函数和普通函数有什么区别" tabindex="-1">箭头函数和普通函数有什么区别 <a class="header-anchor" href="#箭头函数和普通函数有什么区别" aria-label="Permalink to &quot;箭头函数和普通函数有什么区别&quot;">​</a></h3><ul><li>箭头函数没有 this 对象，函数体内的 this 是定义时所在的对象，而不是使用时的对象</li><li>不可以当作构造函数使用，也就是说，不可以对箭头函数使用 new 命令，否则会抛出一个错误</li><li>不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替</li><li>不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数 <ul><li>衍生 generator 函数。生成器，yield，开始，中断</li></ul></li></ul><h3 id="数组和类数组的区别-arguments" tabindex="-1">数组和类数组的区别（arguments） <a class="header-anchor" href="#数组和类数组的区别-arguments" aria-label="Permalink to &quot;数组和类数组的区别（arguments）&quot;">​</a></h3><ul><li>数组是数组，类数组是对象</li><li>类数组是拥有 length 属性和索引属性的对象</li><li>区别：类数组是对象，它的原型关系和数组不同</li></ul><p>常见的类数组还有</p><ul><li>用 getElementsByTagName/ClassName() 获取的 HTMLCollection</li><li>用 querySelector 获取的 nodeList</li></ul><h4 id="类数组如何转换为数组" tabindex="-1">类数组如何转换为数组 <a class="header-anchor" href="#类数组如何转换为数组" aria-label="Permalink to &quot;类数组如何转换为数组&quot;">​</a></h4><p>以下几种方法都可以将类数组转换为数组：</p><ul><li><p><code>Array.from(likeArray)</code></p></li><li><p>展开运算符：<code>[...likeArray]</code></p></li><li><p><code>Array.prototype.slice(likeArray, 0)</code></p></li><li><p><code>Array.prototype.concat.apply([], arguments)</code></p></li></ul><p>相关文章：<a href="https://docs-go.vercel.app/JavaScript/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81.html" target="_blank" rel="noreferrer">防抖与节流</a></p><h2 id="_3-闭包" tabindex="-1">3.闭包 <a class="header-anchor" href="#_3-闭包" aria-label="Permalink to &quot;3.闭包&quot;">​</a></h2><h3 id="什么是闭包" tabindex="-1">什么是闭包？ <a class="header-anchor" href="#什么是闭包" aria-label="Permalink to &quot;什么是闭包？&quot;">​</a></h3><p>闭包就是一个绑定了执行环境的函数，它利用词法作用域的特性，在函数嵌套时，内层函数引用外层函数作用域下的变量，并且内层函数在全局环境下可访问，就形成了闭包</p><h3 id="闭包的优缺点" tabindex="-1">闭包的优缺点 <a class="header-anchor" href="#闭包的优缺点" aria-label="Permalink to &quot;闭包的优缺点&quot;">​</a></h3><ul><li>优点 <ul><li>保护私有变量</li><li>避免全局变量污染</li><li>让一些变量始终存在内容中（是优点）</li></ul></li><li>缺点 <ul><li>一直存在内存中（也是缺点）</li></ul></li></ul><h3 id="闭包的应用" tabindex="-1">闭包的应用 <a class="header-anchor" href="#闭包的应用" aria-label="Permalink to &quot;闭包的应用&quot;">​</a></h3><p>应用场景有两处，一是作为返回值，二是作为参数传递</p><p>像函数式编程、面向事件编程、模块化、私有实例变量都是闭包的应用场景</p><p>衍生问题： add(1)(2)(3)</p><h3 id="实现-add-1-2-3" tabindex="-1">实现 add(1)(2)(3) <a class="header-anchor" href="#实现-add-1-2-3" aria-label="Permalink to &quot;实现 add(1)(2)(3)&quot;">​</a></h3><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">y</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">z</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> z;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> curried</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (args.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fn.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">args);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> curried</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fn, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">args, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">arg2);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> curriedAdd</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> curried</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(add);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">curriedAdd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">curriedAdd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">curriedAdd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>相关文章：<a href="https://docs-go.vercel.app/JavaScript/%E9%97%AD%E5%8C%85.html" target="_blank" rel="noreferrer">闭包</a></p><h2 id="_4-promise-是什么" tabindex="-1">4.Promise 是什么 <a class="header-anchor" href="#_4-promise-是什么" aria-label="Permalink to &quot;4.Promise 是什么&quot;">​</a></h2><p>Promise 是 JavaScript 中用于处理异步操作的一种解决方案。它可以让异步代码的执行看起来更像同步代码，从而提高代码的可读性和可维护性，与之比较的是传统的回调函数</p><p>Promise 有三种状态：pending（等待）、fulfilled（成功）和 rejected（失败），Promise 的状态只能从 pending 转变为 fulfilled 或 rejected，且一旦状态确定就不会再改变</p><p>Promise 的实现原理如下：</p><ol><li>每个 Promise 实例都有一个 then 方法，用于注册成功和失败的回调函数</li><li>当异步操作完成时，Promise 实例会自动调用相应的回调函数，并将结果传递给回调函数</li><li>Promise 使用微任务队列来管理回调函数的执行顺序，保证了代码的执行顺序</li><li>Promise 还支持链式调用，可以在 then 方法中返回一个新的 Promise 实例，从而实现复杂的异步流程控制</li></ol><p>衍生问题：手写 Promise.all 、手写 Promise.allSettle</p><h3 id="手写-promise-all" tabindex="-1">手写 Promise.all <a class="header-anchor" href="#手写-promise-all" aria-label="Permalink to &quot;手写 Promise.all&quot;">​</a></h3><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> all</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">iterable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">reject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> results</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(promises.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> completedCount </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        promises.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // 确保即使是非 Promise 的值也能处理</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">            Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(promise)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                    results[index] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                    completedCount</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                    // 当所有 Promise 都成功时</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (completedCount </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> promises.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                        resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(results);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">reason</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                    // 如果任何一个 Promise 失败，则立即 reject</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                    reject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(reason);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        });</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 如果传入的是空数组，则直接 resolve 空数组</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (promises.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(results);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Promose.all 的缺陷在于只要其中任何一个 promise 失败都会执行 reject，并且 reject 是第一个抛出的错误信息，只有所有的 promise 都 resolve 时才会调用 .then 中的回调函数</p><h3 id="手写-promise-allsettled" tabindex="-1">手写 Promise.allSettled <a class="header-anchor" href="#手写-promise-allsettled" aria-label="Permalink to &quot;手写 Promise.allSettled&quot;">​</a></h3><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> allSettled</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">promises</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> results</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(promise.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> completedCount </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        promises.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">            Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(promise)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            	.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                	results[index] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                        status: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;fulfilled&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                        value,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">reason</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                results[index] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                    status: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;rejected&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                    reason,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">finally</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                completedCount</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (completedCount </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> promises.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                    resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(results)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Promise.all 和 Promise.allSettled 最大的不同：Promise.allSettled 永远不会被 reject</p><h2 id="_5-fiber-是什么-为什么需要-fiber" tabindex="-1">5. Fiber 是什么，为什么需要 Fiber <a class="header-anchor" href="#_5-fiber-是什么-为什么需要-fiber" aria-label="Permalink to &quot;5. Fiber 是什么，为什么需要 Fiber&quot;">​</a></h2><h3 id="什么是-react-fiber" tabindex="-1">什么是 React Fiber <a class="header-anchor" href="#什么是-react-fiber" aria-label="Permalink to &quot;什么是 React Fiber&quot;">​</a></h3><ul><li>Fiber 是 React 内部的一种新的协调算法，用于对 React 组件树进行调度和渲染</li><li>它使用了一种基于链表数据结构来表示组件树（称之为Fiber树），这个数据结构允许 React 执行更加颗粒的控制和分段计算</li></ul><h3 id="为什么需要-react-fiber" tabindex="-1">为什么需要 React Fiber <a class="header-anchor" href="#为什么需要-react-fiber" aria-label="Permalink to &quot;为什么需要 React Fiber&quot;">​</a></h3><ul><li>在 React 16 之前面临的主要性能问题是：当组件很庞大时，更新状态可能造成页面卡顿，根本原因在于更新流程是同步、不可中断的。React 16 重写了代码，提出 Fiber 架构，它是可异步中断的</li><li>传统的 React Reconciler 算法存在一些问题，例如无法暂停、恢复或者放弃正在执行的工作，这会导致高优先级的任务被阻塞</li><li>React Fiber 通过将组件树的递归更新拆分为多个子任务，使 React 可以对任务进行暂停、恢复和放弃等操作，从而提高用户交互的响应性</li><li>Fiber 还支持增量渲染，可以将渲染工作分批完成，而不是一次性完成，从而使得 React 应用在执行大量计算时也能保持流畅的用户体验</li></ul><h3 id="fiber-的工作原理" tabindex="-1">Fiber 的工作原理 <a class="header-anchor" href="#fiber-的工作原理" aria-label="Permalink to &quot;Fiber 的工作原理&quot;">​</a></h3><ul><li>Fiber 中使用了一种基于链表的数据结构来表示组件树，称为 Fiber 树</li><li>Fiber 树中的每个节点就是一个 Fiber 对象，包含了组件的状态信息和更新操作</li><li>React 在更新组件时，会根据新旧 Fiber 树之间的差异计算出需要更新的部分，并将更新任务拆分成多个子任务</li></ul><p>真实 DOM 对应在内存中的 Fiber 节点会形成 Fiber 树，这棵 Fiber 树在 React 中叫 current Fiber，也就是当前 DOM 树对应的 Fiber 树，而正在构建 Fiber 树的叫 workInProgress Fiber，这两棵树的节点通过 alternate 相连</p><h3 id="fiber-的渲染流程" tabindex="-1">Fiber 的渲染流程 <a class="header-anchor" href="#fiber-的渲染流程" aria-label="Permalink to &quot;Fiber 的渲染流程&quot;">​</a></h3><ol><li>初次渲染：当应用首次启动时，会构造一颗全新的 Fiber 树，即创建虚拟 DOM 并将其转换为 Fiber 节点</li><li>数据更新：当应用的状态发生变化时，React 会比较新旧两棵 Fiber 树，找到差异并更新到真实 DOM</li><li>渲染过程： <ol><li>输入阶段：从 react-dom 包开始，将更新请求传递给调度器（Scheduler）</li><li>调度阶段：调度起将更多任务拆分成多个工作单元，并根据优先级分批执行</li><li>提交阶段：完成所有工作单元后，将变更应用到真实 DOM</li></ol></li><li>中断与恢复：Fiber 架构支持将渲染过程中断并恢复，以确保应用的响应性</li></ol><p>相关文章：<a href="https://docs-go.vercel.app/React/Fiber.html" target="_blank" rel="noreferrer">Fiber 的作用和原理</a></p><h2 id="_6-数据流-redux-是什么" tabindex="-1">6. 数据流： Redux 是什么？ <a class="header-anchor" href="#_6-数据流-redux-是什么" aria-label="Permalink to &quot;6. 数据流： Redux 是什么？&quot;">​</a></h2><p>Redux 是 JavaScript 状态容器，能提供可预测化的状态管理</p><p>它认为：</p><ul><li>Web 应用是一个状态机，视图与状态时一一对应的</li><li>所有的状态，保存在一个对象里</li></ul><p>单一数据源、state 只读、使用 reducer 纯函数修改数据</p><p>Redux 是一个用户管理应用状态的开源 JavaScript 库，它提供了一种可预测的状态容器，帮助应用开发更加一致和可维护。Redux 基于 Flux 架构模式，采用单一数据源的方式管理应用的全局状态</p><p>Redux 的核心概念包括：</p><ol><li>Store：存储应用的整个状态</li><li>Action：描述应用状态变化的事件</li><li>Reducer：根据 Action 更新 Store 中的状态</li></ol><p>Redux 的工作流程如下：</p><ol><li>用户在应用中触发某个事件，比如点击按钮</li><li>应用分发一个 Action 对象，描述这个事件</li><li>Reducer 函数接收这个 Action，并根据其更新 Store 中的状态</li><li>Store 中的状态发生变化，React 组件会感知到这个变化并重新渲染</li></ol><p>Redux 是状态管理库，不仅适用于 react，还可以作用于 vue</p><p>它的特点是一个 store、reducer 纯函数、通过 dispatch 一个 action 来修改 store</p><p>即用户 dispatch 一个动作，传给纯函数 reducer，reducer 接受两个参数，一个为原本的 store，另一个为动作，调用完毕后返回新的 store，用户监听 store 变化，就能实时知道 store 的变化</p><p>Redux 的主要优点包括：</p><ol><li>提供可预测的状态管理方式，增强应用的可维护性</li><li>单一数据源使得状态更新更加清晰和可控</li><li>通过纯函数 Reducer 实现状态更新，增强代码的可测试性</li><li>与 React 配合良好，有利于构建复杂的、大规模的 Web 应用</li></ol><p>衍生问题：React-Redux是什么？Mobx 是什么？dva是什么？zustand 是什么？</p><h3 id="react-redux是什么" tabindex="-1">React-Redux是什么 <a class="header-anchor" href="#react-redux是什么" aria-label="Permalink to &quot;React-Redux是什么&quot;">​</a></h3><p>React-Redux 是专门为 React 应用程序设计的状态管理库。它是 Redux 库的一个绑定层，提供了将 Redux 状态管理和 React 组合结合的方式</p><p>典型的工作流程：</p><ol><li>创建 Redux store 并定义 action、reducer 等</li><li>使用 connect 函数将 React 组件与 Redux store 进行绑定</li><li>在组件中通过 mapStateToProps 和 mapDispatchToProps 访问和更新状态</li><li>当状态发生变化时，React-Redux 会自动触发组件的重新渲染</li></ol><h3 id="mobx-是什么" tabindex="-1">Mobx 是什么 <a class="header-anchor" href="#mobx-是什么" aria-label="Permalink to &quot;Mobx 是什么&quot;">​</a></h3><p>Mobx 是一个轻量级的状态管理库，它通过观察者模式来管理应用程序的状态。与 Redux 等单向数据流框架不同，Mobx 采用的是响应式编程的思想</p><p>工作流程如下：</p><ul><li>定义可观察的状态（observable）</li><li>创建衍生状态（computed）</li><li>订阅状态变化并更新 UI（observer）</li><li>通过 action 修改状态</li></ul><h3 id="dva是什么" tabindex="-1">dva是什么 <a class="header-anchor" href="#dva是什么" aria-label="Permalink to &quot;dva是什么&quot;">​</a></h3><p>Dva 是一个基于 Redux 和 React-Router 的轻量级前端框架，它提供了一种更加简单和声明式的方式来管理 React 应用程序的状态</p><p>定义 model、注册 model 到 dva 应用，使用 connect 连接组件和 model</p><h3 id="zustand-是什么" tabindex="-1">zustand 是什么 <a class="header-anchor" href="#zustand-是什么" aria-label="Permalink to &quot;zustand 是什么&quot;">​</a></h3><p>Zustand 是一个简单、轻量级的 JavaScript 状态管理库，主要用于 React 应用程序。它提供了一种全新的、基于 Hooks 的状态管理方式，旨在解决 Redux 等库的复杂性和样板代码问题</p><p>使用 Zustand 的典型流程如下：</p><ol><li>创建一个 store，定义状态和更新状态的 actions</li><li>在组件中使用 useStore hook 订阅和更新状态</li><li>如果需要，可以创建多个子 store 进行模块化管理</li></ol><p>相关文章：<a href="https://docs-go.vercel.app/React/%E7%94%9F%E6%80%81/%E4%BB%8ERedux%E8%AF%B4%E8%B5%B7%EF%BC%8C%E5%88%B0%E6%89%8B%E5%86%99%EF%BC%8C%E5%86%8D%E5%88%B0%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.html" target="_blank" rel="noreferrer">从 Redux 说起，到手写，再到状态管理</a></p><h2 id="_7-浏览器输入-url-到页面渲染都经历了什么" tabindex="-1">7. 浏览器输入 url 到页面渲染都经历了什么 <a class="header-anchor" href="#_7-浏览器输入-url-到页面渲染都经历了什么" aria-label="Permalink to &quot;7. 浏览器输入 url 到页面渲染都经历了什么&quot;">​</a></h2><p>输入 url，敲击键盘，浏览器判断输入的 url 是否为网址，如果不是网址，再通过浏览器默认搜索引擎拼接输入的值，前往搜索引擎页面；如果是网址，则构建请求。</p><p>浏览器判断是否有缓存，如果有，则返回资源给浏览器（之后浏览器进行解析），如果没有，则先判断DNS是否有缓存，如果有直接返回 ip 地址，如果没有则 DNS 解析，并缓存 DNS。</p><p>获取后等待 TCP 连接，建立连接后，发起 HTTP 请求，服务器返回状态和数据。判断是否与打开的网址是同一个站点，如果是，使用相同的渲染进程渲染页面，如果不是，浏览器渲染 HTML、CSS、JS。经历重绘与回流最终构建出渲染树，GUI 线程接管渲染页面</p><p>其中缓存部分，先判断它是否有强缓存再判断协商缓存。执行顺序为：先判断 Cache-Control （HTTP 1.1）是否失效，未失效返回缓存；失效则判断 Expires（HTTP 1.0） 是否失效，未失效返回缓存；失效则判断协商缓存 ETag（HTTP 1.1），请求时请求头中带有条件请求<code>If-No-Match</code>，判断状态是否为304，如果是则资源未变，返回缓存内容，如果不是，则请求服务器返回资源并缓存住缓存信息（Cache-Control 以及 ETag 等）；如果 ETag 不可用，则判断上次响应中是否有Last-Modified，如果是，则发起请求，请求投中带有条件请求 <code>If-Modified-Since</code>，逻辑与 <code>If-No-Match</code> 一样</p><p>整体流程图：</p><p><img src="https://pub-15dc9987604d4311befe731fecc8adb9.r2.dev/98958c07ee7c69fcf8c8fa0be974da2a.png" alt="缓存示意图"></p><p>衍生问题：重绘与回流</p><h3 id="重绘与回流" tabindex="-1">重绘与回流 <a class="header-anchor" href="#重绘与回流" aria-label="Permalink to &quot;重绘与回流&quot;">​</a></h3><p>重绘是元素的样式发生改变，不影响它所在的文档流的位置</p><p>回流是元素的尺寸、结构或者某些属性发生改变，浏览器需要重新计算它所在的位置，然后重新渲染页面的过程</p><p>回流必定会触发重绘，但重绘不一定会引起回流</p><p>相关文章：<a href="https://docs-go.vercel.app/Browser/%E4%BB%8Eurl%E8%BE%93%E5%85%A5%E5%88%B0%E8%BF%94%E5%9B%9E%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BF%87%E7%A8%8B.html" target="_blank" rel="noreferrer">从 url 输入到返回请求的过程</a></p><p>相关文章：<a href="https://docs-go.vercel.app/HTTP/HTTP%E7%BC%93%E5%AD%98.html" target="_blank" rel="noreferrer">面试常客：HTTP 缓存</a></p><h2 id="_8-http-1、2、3-的区别" tabindex="-1">8. HTTP 1、2、3 的区别 <a class="header-anchor" href="#_8-http-1、2、3-的区别" aria-label="Permalink to &quot;8. HTTP 1、2、3 的区别&quot;">​</a></h2><h3 id="http-的发展史" tabindex="-1">HTTP 的发展史 <a class="header-anchor" href="#http-的发展史" aria-label="Permalink to &quot;HTTP 的发展史&quot;">​</a></h3><p>HTTP1</p><p>HTTP1.1</p><p>HTTP2</p><p>HTTP3</p><p>HTTP1 没有 keep-alive ，每次发送请求，都要连接一个 tcp</p><p>HTTP1.1 加了 connect: keep-alive，复用一个 TCP 连接</p><p>缺点是工作流程是请求-响应，请求发出去后等待响应，然后再发送请求，但对同一个服务器来说，可以建立6 个 tcp 连接。所以理论上最多可以同时请求 6 个文件</p><p>这个现象叫做：<strong>队头阻塞</strong></p><p>解决方案</p><ul><li><p>并发连接（多建立几个 TCP 连接，一个服务器最多建立 6 个 TCP 连接）</p></li><li><p>域名分片：一个域名最多并发六个长连接，那我多个域名</p></li><li><p>多路复用：HTTP2 的解决方案</p></li></ul><p>HTTP2 多路复用</p><p>多路复用特点：把请求和响应当作一个流，每个流都有一个 id，每个流可以有多个帧，帧上保留数据</p><p>即相同域名多个请求，共享同一个 TCP 连接，降低了延迟</p><p>工作原理如下：</p><ol><li>客户端和服务器建立一个 TCP 连接后，就可以同时发送多个 HTTP 请求</li><li>每个请求和响应都会分配一个唯一的流（Stream）标识符</li><li>流之间是并行独立的，互不干扰</li><li>服务器可以交错地发送请求的响应数据包，客户端能够根据流 ID 将其重新组装</li></ol><p>HTTP2的其他特点：请求优先级，二进制传输，数据流，服务器推送，头部压缩</p><p>缺点是：TCP 会丢包</p><p>HTTP3</p><p>解决 TCP 连接的问题</p><h3 id="https" tabindex="-1">HTTPS <a class="header-anchor" href="#https" aria-label="Permalink to &quot;HTTPS&quot;">​</a></h3><p>在 HTTP 的基础上加了一层 SSL 协议，为加密协议</p><h3 id="http-缓存" tabindex="-1">HTTP 缓存 <a class="header-anchor" href="#http-缓存" aria-label="Permalink to &quot;HTTP 缓存&quot;">​</a></h3><p>HTTP 缓存分为强缓存和协商缓存</p><h4 id="强缓存" tabindex="-1">强缓存 <a class="header-anchor" href="#强缓存" aria-label="Permalink to &quot;强缓存&quot;">​</a></h4><p>HTTP 1 是 expires，设置过期时间来判断</p><p>HTTP 1.1 是 cache-control 设置过期时长来判断</p><p><code>cache-control:max-age=1000</code></p><p>同时存在时，cache-control 的优先级大于 expires</p><h4 id="协商缓存" tabindex="-1">协商缓存 <a class="header-anchor" href="#协商缓存" aria-label="Permalink to &quot;协商缓存&quot;">​</a></h4><p>HTTP 1.0 通过 last-modified，即最后修改时间来判断是否过期</p><p>HTTP 1.1 通过 etag，生成文件唯一标识来判断是否过期</p><p>从精准度的角度看，etag 比 last-modified 强（last-modified 的感知单位是秒）</p><p>从性能角度看，last-modified 比 etag 强</p><p>两则同时存在时，etag 的优先级大于 last-modified</p><h4 id="http-状态码" tabindex="-1">HTTP 状态码 <a class="header-anchor" href="#http-状态码" aria-label="Permalink to &quot;HTTP 状态码&quot;">​</a></h4><p>301 - 永久重定向</p><p>302 - 临时重定向</p><p>304 - 协商缓存重定向</p><p>401 - 未授权</p><p>403 - 服务器收到请求，但是拒绝提供服务，即资源不可用</p><p>404 - 无法找到请求资源</p><p>408 - 请求超时</p><p>414 - 请求 URI 过长</p><p>更多内容：<a href="./../HTTP/HTTP状态码.html">HTTP 状态码</a></p><h2 id="_9-你常用的性能优化" tabindex="-1">9. 你常用的性能优化 <a class="header-anchor" href="#_9-你常用的性能优化" aria-label="Permalink to &quot;9. 你常用的性能优化&quot;">​</a></h2><h3 id="http方面优化" tabindex="-1">HTTP方面优化 <a class="header-anchor" href="#http方面优化" aria-label="Permalink to &quot;HTTP方面优化&quot;">​</a></h3><ul><li><p>开启 HTTP2（特点：对头阻塞）</p></li><li><p>使用缓存：利用 HTTP 缓存、代理服务器缓存（开启 gzip 压缩）、应用程序缓存等减少重复请求</p></li><li><p>减少 HTTP 请求（开启 HTTP2 后这就不是个问题了）：合并 CSS、JavaScript 和图片文件，减少页面加载时的 HTTP 请求输了</p></li><li><p>使用 CDN：OSS/CDN 可以将静态资源分发到全球各个服务器</p><ul><li>一些比较大的图表库（如echart/map），可以放在 CDN 上，减少总包的体积，加快访问速度</li></ul></li><li><p>服务器开启 gzip 压缩</p></li></ul><h3 id="页面渲染优化" tabindex="-1">页面渲染优化 <a class="header-anchor" href="#页面渲染优化" aria-label="Permalink to &quot;页面渲染优化&quot;">​</a></h3><ul><li>减少 DOM 操作：尽量减少对 DOM 的操作，例如使用事件委托、CSS 动画</li><li>使用懒加载：懒加载可以延迟加载非关键资源，从而提高页面加载速度</li><li>使用服务器渲染（SSR）：服务端渲染可以在服务器端生成 HTML 页面，减少客户端的加载时间</li><li>首屏静态html：既然要加快，那就做到极致，首屏是个静态页</li><li>使用 Web 字体：使用 Web 字体代替图片可以减少“资源”文件数量及加载时间</li><li>如果使用中文字体，可使用字蛛减少字体大小</li><li>优化图片格式、大小：压缩图片大小、使用 WebP 、AVIF格式、懒加载图片等方式可以减少加载时间</li><li>将 CSS 放头部、JavaScript 脚本放尾部</li><li>防抖节流</li><li>减少回流（重排）和重绘</li><li>CSS 书写顺序</li><li>async defer</li></ul><h3 id="webpack-等打包工具的性能优化" tabindex="-1">Webpack 等打包工具的性能优化 <a class="header-anchor" href="#webpack-等打包工具的性能优化" aria-label="Permalink to &quot;Webpack 等打包工具的性能优化&quot;">​</a></h3><ul><li>拆包</li><li>配置 Webpack，压缩 JS、CSS、图片等静态资源大小（资源压缩）</li><li>Tree shaking 去除死代码（生产模式自动做 Tree shaking）</li><li>使用最新版本的 webpack 或者是其他性能更好的打包库</li></ul><h3 id="react-框架做的事情" tabindex="-1">React 框架做的事情 <a class="header-anchor" href="#react-框架做的事情" aria-label="Permalink to &quot;React 框架做的事情&quot;">​</a></h3><ul><li>使用 usememo(缓存值)、useCallback（缓存回调函数）+ memo（避免重复渲染）</li><li>路由懒加载（使用 react.lazy）</li><li>组件懒渲染</li><li>Suspense</li><li>分页</li><li>虚拟列表</li><li>列表项使用 key 属性</li><li>第三方插件按需引入</li><li>使用 Fragment 或者空标签减少层级</li><li>SSR 渲染</li></ul><h3 id="图片的优化" tabindex="-1">图片的优化 <a class="header-anchor" href="#图片的优化" aria-label="Permalink to &quot;图片的优化&quot;">​</a></h3><ul><li><p>图片动态裁剪</p></li><li><p>图片懒加载</p><ul><li>图片懒加载实现原理</li><li>先通过 HTML 自定义属性 data-xxx 先暂存 src 的值，然后在图片出现在屏幕可视区域时，再将 data-xxx 的值赋值到 img 的scr 属性即可</li></ul></li><li><p>使用字体图标</p></li><li><p>图片转 base64 格式</p></li><li><p>图片资源压缩</p><ul><li>tinypng 图片资源压缩</li></ul></li><li><p>图片资源放到 OSS 上</p></li><li><p>图片格式转换</p><ul><li>转成 webp、AVIF格式更现代的压缩图片格式</li></ul></li></ul><h4 id="路由懒加载" tabindex="-1">路由懒加载 <a class="header-anchor" href="#路由懒加载" aria-label="Permalink to &quot;路由懒加载&quot;">​</a></h4><p>单页面应用，一个路由对应一个页面</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> React, { Suspense } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;react&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> OtherComponent</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> React.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">lazy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./OtherComponent&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Suspense</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fallback</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Loading...&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;}&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">OtherComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      &lt;/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Suspense</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h5 id="路由懒加载的原理" tabindex="-1">路由懒加载的原理 <a class="header-anchor" href="#路由懒加载的原理" aria-label="Permalink to &quot;路由懒加载的原理&quot;">​</a></h5><p>懒加载前提的实现：ES6 的动态加载模块——<code>import()</code>，它返回的是一个 promise</p><p>当 webpack 解析到 import 语法时，会自动进行代码分割</p><h4 id="合理的-tree-shaking" tabindex="-1">合理的 Tree Shaking <a class="header-anchor" href="#合理的-tree-shaking" aria-label="Permalink to &quot;合理的 Tree Shaking&quot;">​</a></h4><p>作用：消除无用的 JS 代码，减少代码体积</p><h5 id="tree-shaking-原理" tabindex="-1">Tree-Shaking 原理 <a class="header-anchor" href="#tree-shaking-原理" aria-label="Permalink to &quot;Tree-Shaking 原理&quot;">​</a></h5><p>依赖 ES6 的模块特性，ES6 模块依赖关系是确定的，和运行时的状态无关，可以进行可靠的静态分析</p><p>简单来说，根据 ES Modules 的静态分析</p><h4 id="组件懒渲染" tabindex="-1">组件懒渲染 <a class="header-anchor" href="#组件懒渲染" aria-label="Permalink to &quot;组件懒渲染&quot;">​</a></h4><p>当组件进入或即将进入可视区域时才渲染组件。常见的组件 Modal/Drawer 等，当 visible 属性为 true 时才渲染组件内容，也可以认为是懒渲染的一种实现</p><h5 id="react-memo-减少react子组件渲染" tabindex="-1">React.memo 减少React子组件渲染 <a class="header-anchor" href="#react-memo-减少react子组件渲染" aria-label="Permalink to &quot;React.memo 减少React子组件渲染&quot;">​</a></h5><p>配合 React.useCallback 和 React.useMemo</p><h4 id="使用骨架屏或加载提示" tabindex="-1">使用骨架屏或加载提示 <a class="header-anchor" href="#使用骨架屏或加载提示" aria-label="Permalink to &quot;使用骨架屏或加载提示&quot;">​</a></h4><p>在项目打包时将骨架屏的内容直接放在 HTML 文件的根节点上</p><h4 id="长列表虚拟滚动" tabindex="-1">长列表虚拟滚动 <a class="header-anchor" href="#长列表虚拟滚动" aria-label="Permalink to &quot;长列表虚拟滚动&quot;">​</a></h4><p>只渲染可视区域的列表项，非可见区域的不渲染</p><h5 id="虚拟列表的原理" tabindex="-1">虚拟列表的原理 <a class="header-anchor" href="#虚拟列表的原理" aria-label="Permalink to &quot;虚拟列表的原理&quot;">​</a></h5><p>计算出列表总高度，并在触发滚动事件时根据 scrollTop 值不断更新 startIndex 以及 endIndex，以此从列表数据 listData 中截取对应元素</p><p>虚拟滚动的缺点：</p><p>频繁的计算导致会有短暂的白屏现象，可以通过节流来限制触发频率</p><p>加上为列表管理加一些“上、下缓冲区”，即在可视区域之外预渲染一些元素</p><blockquote><p>通过 IntersectionObserver 和 getBoundingClientRect 也可实现</p></blockquote><h4 id="web-worker-优化长任务" tabindex="-1">Web Worker 优化长任务 <a class="header-anchor" href="#web-worker-优化长任务" aria-label="Permalink to &quot;Web Worker 优化长任务&quot;">​</a></h4><p>由于浏览器 GUI 渲染线程与 JS 引擎线程是互斥关系，所以当页面中有长任务时，会造成页面 UI 阻塞，出现界面卡顿、掉帧等情况</p><p>一些需要大量计算的数据可以放在 web worker 上计算，计算好后再塞入页面中</p><h4 id="js-的六种加载方式" tabindex="-1">JS 的六种加载方式 <a class="header-anchor" href="#js-的六种加载方式" aria-label="Permalink to &quot;JS 的六种加载方式&quot;">​</a></h4><p><strong>正常模式</strong></p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;index.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>这种情况下 JS 会阻塞 DOM 渲染</p><p><strong>async 模式</strong></p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> async</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;index.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>异步模式，JS 不会阻塞 DOM 的渲染，async 加载是无顺序的，当它加载结束，JS 会立即执行</p><p>使用场景：埋点统计、客服系统</p><p><strong>defer 模式</strong></p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> defer</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;index.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>defer 模式下，JS 的加载也是异步的，但 defer 资源会在 <code>DOMContentLoaded</code> 执行之前，并且 defer 是有顺序的加载</p><p><strong>module 模式</strong></p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;module&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { a } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./a.js&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/script&gt;</span></span></code></pre></div><p>在主流现代浏览器中，script 标签的属性可以加上 <code>type=&quot;module&quot;</code>，浏览器会对内部的 import 引用发起 HTTP 请求，获取模块内容。这时 script 的行为会像是 defer 一样，在后台下载，并且等待 DOM 解析</p><p>Vite 就是利用浏览器支持原生的 <code>es module</code> 模块，开发时跳过打包的过程，提升编译效率</p><p><strong>preload</strong></p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">link</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> rel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;preload&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;script&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> href</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;index.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>link 标签的 preload 属性：用于提前加载一些需要的依赖，这些资源会优先加载</p><p>preload 特点</p><p>preload 加载的资源是在浏览器渲染机制之前进行处理的，并不会阻塞 onload 事件</p><p>preload 加载的 JS 脚本其加载和执行的过程是分离的，即 preload 会预加载相应的脚本代码，待到需要时自行调用</p><p><strong>prefetch</strong></p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">link</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> rel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;prefetch&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;script&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> href</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;index.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>prefetch 是利用浏览器的空闲时间，加载页面将来可能用到的资源的一种机制；通常可以用于加载其他页面（非首页）所需要的资源，以便加快后续页面的打开速度</p><p>prefetch 特点：</p><p>prefetch 加载的资源可以获取非当前页面所需资源，并且将其放入缓存至少五分钟</p><p>当页面跳转时，未完成的 prefetch 请求不会被中断</p><h5 id="加载方式总结" tabindex="-1">加载方式总结 <a class="header-anchor" href="#加载方式总结" aria-label="Permalink to &quot;加载方式总结&quot;">​</a></h5><p>async、defer 是 script 标签的专属属性，对于网页的其他资源，可以通过 link 的 preload、prefetch 属性来预加载</p><p>现代框架已经将 preload、prefetch 添加到打包流程中，通过配置可以使用</p><p>衍生问题：性能指标、白屏监控</p><h3 id="性能指标" tabindex="-1">性能指标 <a class="header-anchor" href="#性能指标" aria-label="Permalink to &quot;性能指标&quot;">​</a></h3><p><a href="https://pagespeed.web.dev/" target="_blank" rel="noreferrer">pagespeed</a> 或者 Chrome DevTools （Lighthouse）可以分析一个网站的性能、无障碍、最佳做法以及SEO</p><p><strong>三大核心指标（Core Web Vitals）（2020年 Chrome提出）</strong></p><ul><li><p>Largest Contentful Paint（LCP）：最大内容绘制。<code>加载性能</code>指标。2.5s 内加载完视为优秀</p></li><li><p>Interaction to Next Paint（INP）：从交互到下一次绘制的延时。<code>交互体验</code>指标。200ms 内视为优秀</p></li><li><p>Cumulative Layout Shift（CLS）：累计布局偏移。<code>视觉稳定性</code> 指标，100ms 内视为优秀</p></li><li><p>First Input Delay（FID）：首次输入延时。<code>交互体验</code>指标，100ms 内执行完视为优秀</p></li><li><p>PS：2024 年 3 月 INP 取代 FID</p></li></ul><p>因为 FID 有一些局限性</p><ul><li>首次：FID 只上报用户第一次与页面交互的响应性。虽然第一次交互很重要，但并不代表整个页面声明周期</li><li>输入延迟：FID 只测量首次交互的输入延时，即交互开始到事件开始处理这段时间，而事件处理和渲染的耗时，没有被统计</li></ul><p>所以有了新的指标INP，它不仅测量首次交互，而且还测量所有的交互延时。除了输入延时，还包括事件处理时长、渲染延时。它的目标是确保从用户开始交互到下一帧绘制的时间尽可能短，以满足用户进行的所有或大多数交互</p><p><strong>以用户为中心的性能指标</strong></p><ul><li>First Paint（FP）：首次绘制时间 <ul><li>页面第一次绘制像素的时间，2s内优秀</li></ul></li><li>First contentful paint（FCP）：首次内容绘制时间 <ul><li>首次渲染出内容（文本、图像等）的时间，理想值应小于1秒</li></ul></li><li>Largest contentful paint（LCP）：最大内容渲染时间 <ul><li>视窗内最大元素绘制的时间，2.5s内优秀</li></ul></li><li>Interaction to Next Paint（INP）：从交互到下一次绘制的延时。 <ul><li>交互体验指标。200ms 内视为优秀（代替 FID）</li></ul></li><li>First input delay（FID）：首次输入延迟 <ul><li>当用户第一次与站点交互（点击按钮）的浏览器响应的时间，100ms内优秀</li><li>后被 INP 代替</li></ul></li><li>Time to interactive（TTI）：可交互时间 <ul><li>用户首次可以与页面进行有意义互动的时间</li><li>JS 未执行完、长任务阻塞</li></ul></li><li>Total blocking time（TBT）：总阻塞时间 <ul><li>FCP 到 TTI 之间长任务的阻塞时间，总体阻塞用户输入的时间段</li></ul></li><li>Cumulative layput shift（CLS）：累积布局偏移 <ul><li>测量页面视觉稳定性</li></ul></li><li>DOMContentLoaded：浏览器已完全加载 HTML，并构建了 DOM 树，但像 <code>&lt;img&gt;</code> 和样式表之类的外部资源可能尚未加载完成</li><li>load：浏览器不仅加载完成了 HTML，还加载完成了所有外部资源：图片，样式等</li></ul><h3 id="白屏监控" tabindex="-1">白屏监控 <a class="header-anchor" href="#白屏监控" aria-label="Permalink to &quot;白屏监控&quot;">​</a></h3><p>白屏通常指的是页面打开后，浏览器上面的地址栏已经显示完整的 URL，但是页面内容无法渲染，只有白色的空白页面。</p><p>导致白屏的原因大致可分为两类:</p><ul><li>资源加载问题</li><li>代码执行错误</li></ul><p>从现代前端视角来看，这两种原因都跟当前SPA框架的广泛使用有关。</p><p>白屏检测的方法有以下几种</p><p>1.检测根节点是否渲染</p><p>这种方法的原理是在当前主流 SPA 框架下，DOM 一般挂载在一个根节点之下（比如 <code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code> ），发生白屏后通常是根节点下所有 DOM 被卸载。</p><p>2.Mutation Observer 监听 DOM 变化</p><p>可以通过 Mutation Observer 来监听 DOM 树变化，从而判断页面是否白屏。</p><p>3.页面截图</p><p>通过对网页进行截图，对截图进行像素点分析，判断页面是否白屏。</p><h2 id="_10-算法题-两数之和" tabindex="-1">10.算法题：两数之和 <a class="header-anchor" href="#_10-算法题-两数之和" aria-label="Permalink to &quot;10.算法题：两数之和&quot;">​</a></h2><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> twoSum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">target</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">nums</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> map </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> diff </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> target </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums[i];</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (map.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">has</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(diff)) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [map.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(diff), i]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        map.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nums[i], i)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div>`,272)]))}const o=i(h,[["render",t]]);export{g as __pageData,o as default};
